<!DOCTYPE html>
<html lang="">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Wrappers">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Wrappers">
    
    <meta name="keywords" content="Wrappres,hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="it's better to burn out than to fade away">
    <meta name="description" content="Q：Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量因为分类底层结构的限制，不能直接给 Category 添加成员变量，但是可以通过关联对象间接实现 Category 有成员变量的效果。 传送门：OC - Association 关联对象 Q：为什么分类中属性不会自动生成 setter、getter 方法的实现，不会生成成员变量，也不能添加成员变量因为类的内存布">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 面试题(2)">
<meta property="og:url" content="https://wrapperss.github.io/2020/10/05/iOS面试题-2/index.html">
<meta property="og:site_name" content="Wrappers&#39; Studio">
<meta property="og:description" content="Q：Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量因为分类底层结构的限制，不能直接给 Category 添加成员变量，但是可以通过关联对象间接实现 Category 有成员变量的效果。 传送门：OC - Association 关联对象 Q：为什么分类中属性不会自动生成 setter、getter 方法的实现，不会生成成员变量，也不能添加成员变量因为类的内存布">
<meta property="og:locale" content="default">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml version=" 1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="652" height="110">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml version=" 1.0"?=""/><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="920" height="468">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/7/20/1736b686bffee3ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"/>
<meta property="og:updated_time" content="2020-10-05T10:07:06.058Z"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="iOS 面试题(2)"/>
<meta name="twitter:description" content="Q：Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量因为分类底层结构的限制，不能直接给 Category 添加成员变量，但是可以通过关联对象间接实现 Category 有成员变量的效果。 传送门：OC - Association 关联对象 Q：为什么分类中属性不会自动生成 setter、getter 方法的实现，不会生成成员变量，也不能添加成员变量因为类的内存布"/>
<meta name="twitter:image" content="data:image/svg+xml;utf8,<?xml version=" 1.0"?=""/><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="652" height="110">
    <meta http-equiv="Cache-control" content="no-cache"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>iOS 面试题(2) · Wrappres</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)"/>
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/Wrappers.ico"/>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script"/>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script"/>
    <link rel="preload" href="/scripts/main.js" as="script"/>
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin=""/>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin=""/>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer=""/>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</svg></svg></svg></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Wrappres&#39; Studio.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">iOS 面试题(2)</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Wrappres' Studio.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(https://source.unsplash.com/random)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            iOS 面试题(2)
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "iOS">iOS</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">26.3k</span>阅读时长: <span class="post-count reading-time">98 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/10/05</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h4 id="Q：Category-能否添加成员变量？如果可以，如何给-Category-添加成员变量"><a href="#Q：Category-能否添加成员变量？如果可以，如何给-Category-添加成员变量" class="headerlink" title="Q：Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量"></a>Q：Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量</h4><p>因为分类底层结构的限制，不能直接给 Category 添加成员变量，但是可以通过关联对象间接实现 Category 有成员变量的效果。<br> <a href="https://www.jianshu.com/p/0de99fa1409c" target="_blank" rel="noopener">传送门：OC - Association 关联对象</a></p>
<h4 id="Q：为什么分类中属性不会自动生成-setter、getter-方法的实现，不会生成成员变量，也不能添加成员变量"><a href="#Q：为什么分类中属性不会自动生成-setter、getter-方法的实现，不会生成成员变量，也不能添加成员变量" class="headerlink" title="Q：为什么分类中属性不会自动生成 setter、getter 方法的实现，不会生成成员变量，也不能添加成员变量"></a>Q：为什么分类中属性不会自动生成 setter、getter 方法的实现，不会生成成员变量，也不能添加成员变量</h4><p>因为类的内存布局在编译的时候会确定，但是分类是在运行时才加载，在运行时<code>Runtime</code>会将分类的数据，合并到宿主类中。</p>
<h4 id="Q：为什么将以前的方法列表挪动到新的位置用-memmove-呢"><a href="#Q：为什么将以前的方法列表挪动到新的位置用-memmove-呢" class="headerlink" title="Q：为什么将以前的方法列表挪动到新的位置用 memmove 呢"></a>Q：为什么将以前的方法列表挪动到新的位置用 memmove 呢</h4><p>为了保证挪动数据的完整性。而将分类的方法列表合并进来，不用考虑被覆盖的问题，所以用 memcpy 就好。</p>
<h4 id="Q：为什么优先调用最后编译的分类的方法"><a href="#Q：为什么优先调用最后编译的分类的方法" class="headerlink" title="Q：为什么优先调用最后编译的分类的方法"></a>Q：为什么优先调用最后编译的分类的方法</h4><p><code>attachCategories()</code>方法中，从所有未完成整合的分类取出分类的过程是倒序遍历，最先访问最后编译的分类。然后获取该分类中的方法等列表，添加到二维数组中，所以最后编译的分类中的数据最先加到分类二维数组中，最后插入到宿主类的方法列表前面。而消息传递过程中优先查找宿主类中靠前的元素，找到同名方法就进行调用，所以优先调用最后编译的分类的方法。</p>
<h4 id="Q：objc-class-结构体中的-baseMethodList-和-methods-方法列表的区别"><a href="#Q：objc-class-结构体中的-baseMethodList-和-methods-方法列表的区别" class="headerlink" title="Q：objc_class 结构体中的 baseMethodList 和 methods 方法列表的区别"></a>Q：objc_class 结构体中的 baseMethodList 和 methods 方法列表的区别</h4><p>回答此道问题需要先了解<code>Runtime</code>的数据结构<code>objc_class</code>。<br> <a href="https://www.jianshu.com/p/2d5bb68f4a38" target="_blank" rel="noopener">传送门：深入浅出 Runtime（二）：数据结构</a>。</p>
<ul>
<li><code>baseMethodList</code>基础的方法列表，是<code>ro</code>只读的，不可修改，可以看成是合并分类方法列表前的<code>methods</code>的拷贝；</li>
<li>而<code>methods</code>是<code>rw</code>可读写的，将来运行时要合并分类方法列表。</li>
</ul>
<h4 id="Q：Category-中有-load-方法吗？-load-方法是什么时候调用的？-load-方法能继承吗"><a href="#Q：Category-中有-load-方法吗？-load-方法是什么时候调用的？-load-方法能继承吗" class="headerlink" title="Q：Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗"></a>Q：Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗</h4><ol>
<li>分类中有<code>+load</code>方法；</li>
<li><code>+load</code>方法在<code>Runtime</code>加载类、分类的时候调用；</li>
<li><code>+load</code>方法可以继承，但是一般情况下不会手动去调用<code>+load</code>方法，都是让系统自动调用。</li>
</ol>
<h4 id="Q：Category-中有-load-方法吗？-load-方法是什么时候调用的？-load-方法能继承吗-1"><a href="#Q：Category-中有-load-方法吗？-load-方法是什么时候调用的？-load-方法能继承吗-1" class="headerlink" title="Q：Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗"></a>Q：Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗</h4><ol>
<li>分类中有<code>+load</code>方法；</li>
<li><code>+load</code>方法在<code>Runtime</code>加载类、分类的时候调用；</li>
<li><code>+load</code>方法可以继承，但是一般情况下不会手动去调用<code>+load</code>方法，都是让系统自动调用。</li>
</ol>
<h4 id="Q：手动调用-Student-类的-load-方法，但是-Student-类没有实现该方法，为什么会去调用父类的-load-方法，且是调用父类的分类的-load-方法呢"><a href="#Q：手动调用-Student-类的-load-方法，但是-Student-类没有实现该方法，为什么会去调用父类的-load-方法，且是调用父类的分类的-load-方法呢" class="headerlink" title="Q：手动调用 Student 类的 +load 方法，但是 Student 类没有实现该方法，为什么会去调用父类的 +load 方法，且是调用父类的分类的 +load 方法呢"></a>Q：手动调用 Student 类的 +load 方法，但是 Student 类没有实现该方法，为什么会去调用父类的 +load 方法，且是调用父类的分类的 +load 方法呢</h4><p>因为<code>+load</code>方法可以继承，<code>[Student load]</code>手动调用方式为是消息机制<code>objc_msgSend</code>函数的调用，会去类方法列表里找对应的方法，由于 Student 类没有实现，就会去父类的方法列表中查找，且优先调用分类的<code>+load</code>方法。而系统自动调用的<code>+load</code>方法是直接通过函数地址调用的。</p>
<h4 id="Q1：以下打印的-a-的值为多少"><a href="#Q1：以下打印的-a-的值为多少" class="headerlink" title="Q1：以下打印的 a 的值为多少"></a>Q1：以下打印的 a 的值为多少</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a);</span><br></pre></td></tr></table></figure>
<p>答：a &gt;= 10。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打印3次的结果</span></span><br><span class="line"><span class="comment">2020-01-29 02:35:42.070283+0800 多线程[49119:9919097] 12</span></span><br><span class="line"><span class="comment">2020-01-29 02:35:51.528086+0800 多线程[49119:9919097] 10</span></span><br><span class="line"><span class="comment">2020-01-29 02:35:52.285512+0800 多线程[49119:9919097] 15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 如果在打印 a 值之前，将线程睡眠一段时间，结果更明显。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__block <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印3次的结果</span></span><br><span class="line"><span class="comment">2020-01-29 02:38:29.102872+0800 多线程[49139:9921222] 24</span></span><br><span class="line"><span class="comment">2020-01-29 02:38:31.663993+0800 多线程[49139:9921222] 19</span></span><br><span class="line"><span class="comment">2020-01-29 02:38:34.024043+0800 多线程[49139:9921222] 21</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>解析：会发生资源抢夺。当执行<code>while</code>第一次判断<code>a</code>的值时<code>a=0</code>，条件成立，开启一条线程异步执行任务<code>a++</code>。由于异步不用等待当前语句执行完毕，就可以执行下一条语句，所以就会执行到第 6 行代码，再次执行<code>while</code>判断<code>a</code>的值，这时候可能任务<code>a++</code>还未执行，<code>a</code>的值还是 0，所以当<code>a=0</code>时可能会执行两次甚至多次任务<code>a++</code>。同理，当<code>a=1</code>时可能也会执行两次甚至多次任务<code>a++</code>。再由于<code>while</code>的成立条件为<code>a&lt;10</code>，所以至少当<code>a=10</code>的时候才会结束<code>while</code>循环，而当<code>a=10</code>结束循环的时候可能还有<code>n</code>条线程还未执行完毕任务<code>a++</code>，所以打印的<code>a</code>的值<code>&gt;=10</code>。</p>
<h4 id="Q1-扩展：如何输出-a-最终的值"><a href="#Q1-扩展：如何输出-a-最终的值" class="headerlink" title="Q1 扩展：如何输出 a 最终的值"></a>Q1 扩展：如何输出 a 最终的值</h4><p>答：利用队列的 FIFO 规则，如下。需要注意的是，这种方法输出的 a 最终的值不是绝对的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果想输出 a 最终的绝对的值，使用 GCD 队列组：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_notify(group, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Q1-扩展：如何让-a-最终的值为-10"><a href="#Q1-扩展：如何让-a-最终的值为-10" class="headerlink" title="Q1 扩展：如何让 a 最终的值为 10"></a>Q1 扩展：如何让 a 最终的值为 10</h4><p>答：可以使用 GCD 信号量，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">__block <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"a=%d,%@"</span>,a,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a);</span><br></pre></td></tr></table></figure>
<h4 id="Q：通过-KVC-修改属性会触发-KVO-吗"><a href="#Q：通过-KVC-修改属性会触发-KVO-吗" class="headerlink" title="Q：通过 KVC 修改属性会触发 KVO 吗"></a>Q：通过 KVC 修改属性会触发 KVO 吗</h4><p>会，通过<code>KVC</code>修改成员变量值也会触发<code>KVO</code>。</p>
<h4 id="Q：通过-KVC-键值编码技术是否会破坏面向对象的编程方法，或者说违背面向对象的编程思想呢"><a href="#Q：通过-KVC-键值编码技术是否会破坏面向对象的编程方法，或者说违背面向对象的编程思想呢" class="headerlink" title="Q：通过 KVC 键值编码技术是否会破坏面向对象的编程方法，或者说违背面向对象的编程思想呢"></a>Q：通过 KVC 键值编码技术是否会破坏面向对象的编程方法，或者说违背面向对象的编程思想呢</h4><p><code>valueForKey:</code>和<code>setValue:forKey:</code>这里面的<code>key</code>是没有任何限制的，当我们知道一个类或实例它内部的私有变量名称的情况下，我们在外界可以通过已知的<code>key</code>来对它的私有变量进行访问或者赋值的操作，从这个角度来讲<code>KVC</code>键值编码技术会违背面向对象的编程思想。</p>
<h4 id="Q：-既然-weak-更安全，那么为什么已经有了-weak-还要保留-unsafe-unretained"><a href="#Q：-既然-weak-更安全，那么为什么已经有了-weak-还要保留-unsafe-unretained" class="headerlink" title="Q： 既然 **weak 更安全，那么为什么已经有了 **weak 还要保留 __unsafe_unretained"></a>Q： 既然 <strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong><strong>weak 更安全，那么为什么已经有了 </strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong>weak 还要保留 __unsafe_unretained</h4><ul>
<li><p><code>__weak</code>仅在<code>ARC</code>中才能使用，而<code>MRC</code>只能使用<code>__unsafe_unretained</code>；</p>
</li>
<li><p><code>__unsafe_unretained</code>主要跟 C 代码交互；</p>
</li>
<li><p><code>__weak</code>对性能会有一定的消耗，当一个对象<code>dealloc</code>时，需要遍历对象的<code>weak</code>表，把表里的所有<code>weak</code>指针变量值置为<code>nil</code>，指向对象的<code>weak</code>指针越多，性能消耗就越多。所以<code>__unsafe_unretained</code>比<code>__weak</code>快。当明确知道对象的生命周期时，选择<code>__unsafe_unretained</code>会有一些性能提升。 </p>
<p>A 持有 B 对象，当 A 销毁时 B 也销毁。这样当 B 存在，A 就一定会存在。而 B 又要调用 A 的接口时，B 就可以存储 A 的<code>__unsafe_unretained</code>指针。 比如，MyViewController 持有 MyView，MyView 需要调用 MyViewController 的接口。MyView 中就可以存储<code>__unsafe_unretained MyViewController *_viewController</code>。 </p>
<p>虽然这种性能上的提升是很微小的。但当你很清楚这种情况下，<code>__unsafe_unretained</code>也是安全的，自然可以快一点就是一点。而当情况不确定的时候，应该优先选用<code>__weak</code>。</p>
</li>
</ul>
<h4 id="Q：-释放NSAutoreleasePool对象，使用-pool-release-与-pool-drain-的区别"><a href="#Q：-释放NSAutoreleasePool对象，使用-pool-release-与-pool-drain-的区别" class="headerlink" title="Q： 释放NSAutoreleasePool对象，使用[pool release]与[pool drain]的区别"></a>Q： 释放<code>NSAutoreleasePool</code>对象，使用<code>[pool release]</code>与<code>[pool drain]</code>的区别</h4><p>Objective-C 语言本身是支持 GC 机制的，但有平台局限性，仅限于 MacOS 开发中，iOS 开发用的是 RC 机制。在 iOS 的 RC 环境下<code>[pool release]</code>和<code>[pool drain]</code>效果一样，但在 GC 环境下<code>drain</code>会触发 GC 而<code>release</code>不做任何操作。使用<code>[pool drain]</code>更佳，一是它的功能对系统兼容性更强，二是这样可以跟普通对象的<code>release</code>区别开。（注意：苹果在引入<code>ARC</code>时称，已在 OS X Mountain Lion v10.8 中弃用<code>GC</code>机制，而使用<code>ARC</code>替代）</p>
<h4 id="Q：-为什么-block-会产生循环引用"><a href="#Q：-为什么-block-会产生循环引用" class="headerlink" title="Q： 为什么 block 会产生循环引用"></a>Q： 为什么 block 会产生循环引用</h4><ul>
<li>① 相互循环引用： 如果当前<code>block</code>对当前对象的某一成员变量进行捕获的话，可能会对它产生强引用。根据<code>block</code>的变量捕获机制，如果<code>block</code>被拷贝到堆上，且捕获的是对象类型的<code>auto</code>变量，则会连同其所有权修饰符一起捕获，所以如果对象是<code>__strong</code>修饰，则<code>block</code>会对它产生强引用（如果<code>block</code>在栈上就不会强引用）。而当前<code>block</code>可能又由于当前对象对其有一个强引用，就产生了相互循环引用的问题；</li>
<li>② 大环引用： 我们如果使用<code>__block</code>的话，在<code>ARC</code>下可能会产生循环引用（<code>MRC</code>则不会）。由于<code>__block</code>修饰符会将变量包装成一个对象，如果<code>block</code>被拷贝到堆上，则会直接对<code>__block</code>变量产生强引用，而<code>__block</code>如果修饰的是对象的话，会根据对象的所有权修饰符做出相应的操作，形成强引用或者弱引用。如果对象是<code>__strong</code>修饰（如<code>__block id x</code>），则<code>__block</code>变量对它产生强引用（在<code>MRC</code>下则不会），如果这时候该对象是对<code>block</code>持有强引用的话，就产生了大环引用的问题。在<code>ARC</code>下可以通过断环的方式去解除循环引用，可以在<code>block</code>中将指针置为<code>nil</code>（<code>MRC</code>不会循环引用，则不用解决）。但是有一个弊端，如果该<code>block</code>一直得不到调用，循环引用就一直存在。</li>
</ul>
<h4 id="Q：-synthesize现在有什么作用呢"><a href="#Q：-synthesize现在有什么作用呢" class="headerlink" title="Q： @synthesize现在有什么作用呢"></a>Q： <code>@synthesize</code>现在有什么作用呢</h4><p> 如果我们同时重写了<code>setter</code>和<code>getter</code>方法，则编译器就不会为这个<code>@property</code>添加<code>@synthesize</code>，这时候就不存在下划线成员变量，所以我们需要手动添加<code>@synthesize</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@synthesize propertyName = _propertyName;</span><br></pre></td></tr></table></figure>
<p>有时候我们不希望编译器为我们<code>@synthesize</code>，我们希望在程序运行过程中再去决定该属性存取方法的实现，就可以使用<code>@dynamic</code>。</p>
<ul>
<li><code>@dynamic</code> ：告诉编译器不用自动进行<code>@synthesize</code>，等到运行时再添加方法实现，但是它不会影响<code>@property</code>生成的<code>setter</code>和<code>getter</code>方法的声明。<code>@dynamic</code>是 OC 为动态运行时语言的体现。动态运行时语言与编译时语言的区别：动态运行时语言将函数决议推迟到运行时，编译时语言在编译器进行函数决议。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@dynamic propertyName;</span><br></pre></td></tr></table></figure>
<h4 id="Q：block-是如何在-ARC-中工作的"><a href="#Q：block-是如何在-ARC-中工作的" class="headerlink" title="Q：block 是如何在 ARC 中工作的"></a>Q：block 是如何在 ARC 中工作的</h4><p>在<code>ARC</code>下，编译器会根据情况自动将栈上的<code>block</code>复制到堆上，比如<code>block</code>作为函数返回值时，这样你就不必再调用<code>Block Copy</code>。</p>
<p>需要注意的一件事是，在<code>ARC</code>下，<code>NSString * __block myString</code>这样写的话，<code>block</code>会对<code>NSString</code>对象强引用，而不是造成悬垂指针问题。如果你要和<code>MRC</code>保持一致，请使用<code>__block NSString * __unsafe_unretained myString</code>或（更好的是）使用<code>__block NSString * __weak myString</code>。</p>
<h4 id="Q：-哪些类不支持-weak-弱引用"><a href="#Q：-哪些类不支持-weak-弱引用" class="headerlink" title="Q： 哪些类不支持 weak 弱引用"></a>Q： 哪些类不支持 weak 弱引用</h4><p>你当前无法创建对以下类的实例的<code>weak</code>弱引用：NSATSTypesetter、NSColorSpace、NSFont、NSMenuView、NSParagraphStyle、NSSimpleHorizontalTypesetter 和 NSTextView。</p>
<p><strong>注意：</strong> 此外，在 OS X v10.7 中，你无法创建对 NSFontManager，NSFontPanel、NSImage、NSTableCellView、NSViewController、NSWindow 和 NSWindowController 实例的<code>weak</code>弱引用。此外，在 OS X v10.7 中，AV Foundation 框架中的任何类都不支持<code>weak</code>弱引用。</p>
<p>此外，你无法在<code>ARC</code>下创建 NSHashTable、NSMapTable 和 NSPointerArray 类的实例的<code>weak</code>弱引用。</p>
<h3 id="1-对象方法和类方法的区别"><a href="#1-对象方法和类方法的区别" class="headerlink" title="1.对象方法和类方法的区别"></a>1.对象方法和类方法的区别</h3><ul>
<li>对象方法能个访问成员变量。</li>
<li>类方法中不能直接调用对象方法，想要调用对象方法，必须创建或者传入对象。</li>
<li>类方法可以和对象方法重名。</li>
</ul>
<h4 id="引伸-1-如果在类方法中调用-self-会有什么问题"><a href="#引伸-1-如果在类方法中调用-self-会有什么问题" class="headerlink" title="引伸 1.  如果在类方法中调用 self 会有什么问题"></a>引伸 1.  如果在类方法中调用 self 会有什么问题</h4><ul>
<li>在 实例方法中 self 不可以调用类方法，此时的 self 不是 Class。</li>
<li>在类方法中 self 可以调用其他类方法。</li>
<li>在类方法中 self 不可以调用实例方法。</li>
<li><strong>总结</strong>：类方法中的 self，是 class/ 实例方法中 self 是对象的首地址。</li>
</ul>
<h4 id="引申-2-讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的"><a href="#引申-2-讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的" class="headerlink" title="引申 2. 讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的"></a>引申 2. 讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的</h4><ul>
<li>对象的结构体当中存放着 isa 指针和成员变量，isa 指针指向类对象</li>
<li>类对象的 isa 指针指向元类，元类的 isa 指针指向 NSObject 的元类</li>
<li>类对象和元类的结构体有 isa，superClass，cache 等等</li>
</ul>
<h4 id="引申-3-为什么对象方法中没有保存对象结构体里面，而是保存在类对象的结构体里面"><a href="#引申-3-为什么对象方法中没有保存对象结构体里面，而是保存在类对象的结构体里面" class="headerlink" title="引申 3.  为什么对象方法中没有保存对象结构体里面，而是保存在类对象的结构体里面"></a>引申 3.  为什么对象方法中没有保存对象结构体里面，而是保存在类对象的结构体里面</h4><ul>
<li>方法是每个对象相互可以共用的，如果每个对象都存储一份方法列表太浪费内存，由于对象的 isa 是指向类对象的，当调用的时候， 直接去类对象中去查找就可以了，节约了很多内存空间。</li>
</ul>
<h4 id="引申-4-类方法存在哪里？-为什么要有元类的存在"><a href="#引申-4-类方法存在哪里？-为什么要有元类的存在" class="headerlink" title="引申 4. 类方法存在哪里？ 为什么要有元类的存在"></a>引申 4. 类方法存在哪里？ 为什么要有元类的存在</h4><ul>
<li>所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。 为了调用类方法，这个类的 isa 指针必须指向一个包含这些类方法的一个 objc_class 结构体。这就引出了 meta-class 的概念，元类中保存了创建类对象以及类方法所需的所有信息。</li>
</ul>
<h4 id="引申-5-什么是野指针"><a href="#引申-5-什么是野指针" class="headerlink" title="引申 5. 什么是野指针"></a>引申 5. 什么是野指针</h4><ul>
<li><p>野指针就是指向一个被释放或者被收回的对象，但是对指向该对象的指针没有做任何修改，以至于该指针让指向已经回收后的内存地址。</p>
</li>
<li><p>其中访问野指针是没有问题的，使用野指针的时候会出现崩溃 Crash！</p>
<p>样例如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  __<span class="keyword">unsafe_unretained</span> <span class="built_in">UIView</span> *testObj = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"testObj 指针指向的地址:%p 指针本身的地址:%p"</span>, testObj, &amp;testObj);</span><br><span class="line">   [testObj setNeedsLayout];</span><br><span class="line">   <span class="comment">// 可以看到NSlog打印不会闪退，调用[testObj setNeedsLayout];会闪退</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="引申-6-如何检测野指针"><a href="#引申-6-如何检测野指针" class="headerlink" title="引申 6. 如何检测野指针"></a>引申 6. 如何检测野指针</h4><p>这是网友总结的，有兴趣的可以看下：<a href="https://www.jianshu.com/p/9fd4dc046046?utm_source=oschina-app" target="_blank" rel="noopener">www.jianshu.com/p/9fd4dc046……</a> 本人，也就是看看乐呵，其原理啥的，见仁见智吧。开发行业太 j8 难了！</p>
<h4 id="引申-7-导致-Crash-的原因有哪些"><a href="#引申-7-导致-Crash-的原因有哪些" class="headerlink" title="引申 7. 导致 Crash 的原因有哪些"></a>引申 7. 导致 Crash 的原因有哪些</h4><p>1、找不到方法的实现 unrecognized selector sent to instance 2、KVC 造成的 crash 3、EXC_BAD_ACCESS 4、KVO 引起的崩溃 5、集合类相关崩溃 6、多线程中的崩溃 7、Socket 长连接，进入后台没有关闭 8、Watch Dog 超时造成的 crash 9、后台返回 NSNull 导致的崩溃，多见于 Java 做后台服务器开发语言</p>
<h4 id="引申-8-不使用第三方，如何知道已经上线的-App-崩溃问题，-具体到哪一个类的哪一个方法的"><a href="#引申-8-不使用第三方，如何知道已经上线的-App-崩溃问题，-具体到哪一个类的哪一个方法的" class="headerlink" title="引申 8.  不使用第三方，如何知道已经上线的 App 崩溃问题， 具体到哪一个类的哪一个方法的"></a>引申 8.  不使用第三方，如何知道已经上线的 App 崩溃问题， 具体到哪一个类的哪一个方法的</h4><p>大致实现方式如下。 </p>
<ul>
<li>使用 NSSetUncaughtExceptionHandler 可以统计闪退的信息。</li>
<li>将统计到的信息以 data 的形式 利用网络请求发给后台</li>
<li>在后台收集信息，进行排查</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">        <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;my_uncaught_exception_handler);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> my_uncaught_exception_handler (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        <span class="comment">//这里可以取到 NSException 信息</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"***********************************************"</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,exception);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,exception.callStackReturnAddresses);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,exception.callStackSymbols);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"***********************************************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>实现方式如： <a href="https://blog.csdn.net/u013896628/article/details/53837352?utm_medium=distribute.pc_relevant_download.none-task-blog-BlogCommendFromBaidu-8.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-BlogCommendFromBaidu-8.nonecas" target="_blank" rel="noopener">blog.csdn.net/u013896628/……</a></p>
<h3 id="iOS-中内省的几个方法"><a href="#iOS-中内省的几个方法" class="headerlink" title="iOS 中内省的几个方法"></a>iOS 中内省的几个方法</h3><ul>
<li>isMemberOfClass //对象是否是某个类型的对象</li>
<li>isKindOfClass //对象是否是某个类型或某个类型子类的对象</li>
<li>isSubclassOfClass //某个类对象是否是另一个类型的子类</li>
<li>isAncestorOfObject //某个类对象是否是另一个类型的父类</li>
<li>respondsToSelector //是否能响应某个方法</li>
<li>conformsToProtocol //是否遵循某个协议</li>
</ul>
<h4 id="引申-2-、-isEqualToString、isEqual-区别"><a href="#引申-2-、-isEqualToString、isEqual-区别" class="headerlink" title="引申 2. ==、 isEqualToString、isEqual 区别"></a>引申 2. ==、 isEqualToString、isEqual 区别</h4><ul>
<li>== ，比较的是两个指针的值 （内存地址是否相同）。</li>
<li>isEqualToString， 比较的是两个字符串是否相等。</li>
<li>isEqual 判断两个对象在类型和值上是否都一样。</li>
</ul>
<h4 id="引申-3-class-方法和-object-getClass-方法有什么区别"><a href="#引申-3-class-方法和-object-getClass-方法有什么区别" class="headerlink" title="引申 3. class 方法和 object_getClass 方法有什么区别"></a>引申 3. class 方法和 object_getClass 方法有什么区别</h4><ul>
<li>实例 class 方法直接返回 object_getClass(self)  </li>
<li>类 class 直接返回 self</li>
<li>而 object_getClass(类对象)，则返回的是元类</li>
</ul>
<h3 id="3-深拷贝和浅拷贝"><a href="#3-深拷贝和浅拷贝" class="headerlink" title="3.深拷贝和浅拷贝"></a>3.深拷贝和浅拷贝</h3><ul>
<li>所谓深浅指的是是否创建了一个新的对象（开辟了新的内存地址）还是仅仅做了指针的复制。</li>
<li>copy 和 mutableCopy 针对的是可变和不可变，凡涉及 copy 结果均变成不可变，mutableCopy 均变成可变。</li>
<li>mutableCopy 均是深复制。</li>
<li>copy 操作不可变的是浅复制，操作可变的是深赋值。</li>
</ul>
<h3 id="4-NSString-类型为什么要用-copy-修饰"><a href="#4-NSString-类型为什么要用-copy-修饰" class="headerlink" title="4.NSString 类型为什么要用 copy 修饰"></a>4.NSString 类型为什么要用 copy 修饰</h3><ul>
<li>主要是防止 NSString 被修改，如果没有修改的说法用 Strong 也行。</li>
<li>当 NSString 的赋值来源是 NSString 时，strong 和 copy 作用相同。</li>
<li>当 NSString 的赋值来源是 NSMutableString，copy 会做深拷贝，重新生成一个新的对象，修改赋值来源不会影响 NSString 的值。</li>
</ul>
<h3 id="5-iOS-中-block-捕获外部局部变量实际上发生了什么？-block-中又做了什么"><a href="#5-iOS-中-block-捕获外部局部变量实际上发生了什么？-block-中又做了什么" class="headerlink" title="5.iOS 中 block 捕获外部局部变量实际上发生了什么？__block 中又做了什么"></a>5.iOS 中 block 捕获外部局部变量实际上发生了什么？__block 中又做了什么</h3><ul>
<li>block 捕获的是当前在 block 内部执行的外部局部变量的瞬时值， 为什么说瞬时值呢？ 看一下 C++源码中得知， 其内部代码在捕获的同时</li>
<li>其实 block 底层生成了一个和外部变量相同名称的属性值如果内部修改值，其实修改的是捕获之前的值，其捕获的内部的值因代码只做了一次捕获，并没有做再一次的捕获，所以 block 里面不可以修改值。</li>
<li>如果当前捕获的为对象类型，其 block 内部可以认为重新创建了一个指向当前对象内存地址的指针（堆），操控内部操作的东西均为同一块内存地址，所以可以修改当前内部的对象里面的属性，但是不能直接修改当前的指针（无法直接修改栈中的内容）（即重新生成一个新的内存地址）。其原理和捕获基本数据类型一致。</li>
<li>说白了， block 内部可以修改的是堆中的内容， 但不能直接修改栈中的任何东西。</li>
</ul>
<hr>
<ul>
<li>如果加上__block 在运行时创建了一个外部变量的“副本”属性，把栈中的内存地址放到了堆中进而在 block 内部也能修改外部变量的值。</li>
</ul>
<h3 id="6-iOS-Block-为什么用-copy-修饰"><a href="#6-iOS-Block-为什么用-copy-修饰" class="headerlink" title="6.iOS Block 为什么用 copy 修饰"></a>6.iOS Block 为什么用 copy 修饰</h3><ul>
<li>block 是一个对象</li>
<li>MRC 的时候 block 在创建的时候，它的内存比较奇葩，非得分配到栈上，而不是在传统的堆上，它本身的作用于就属于创建的时候（见光死，夭折），一旦在创建时候的作用于外面调用它会导致崩溃。</li>
<li>所以，利用 copy 把原本在栈上的复制到堆里面，就保住了它。</li>
<li><strong>ARC 的时候 由于 ARC 中已经看不到栈中的 block 了。用 strong 和 copy 一样   随意， 用 copy 是遵循其传统，</strong> </li>
</ul>
<h3 id="7-为什么分类中不能创建属性-Property（runtime-除外）"><a href="#7-为什么分类中不能创建属性-Property（runtime-除外）" class="headerlink" title="7. 为什么分类中不能创建属性 Property（runtime 除外）"></a>7. 为什么分类中不能创建属性 Property（runtime 除外）</h3><ul>
<li>分类的实现原理是将 category 中的方法，属性，协议数据放在 category_t 结构体中，然后将结构体内的方法列表拷贝到类对象的方法列表中。 Category 可以添加属性，但是并不会自动生成成员变量及 set/get 方法。因为 category_t 结构体中并不存在成员变量。通过之前对对象的分析我们知道成员变量是存放在实例对象中的，并且编译的那一刻就已经决定好了。而分类是在运行时才去加载的。那么我们就无法再程序运行时将分类的成员变量中添加到实例对象的结构体中。因此分类中不可以添加成员变量。</li>
<li>在往深一点的回答就是 类在内存中的位置是编译时期决定的， 之后再修改代码也不会改变内存中的位置，class_ro_t 的属性在运行期间就不能再改变了， 再添加方法是会修改 class_rw_t 的 methods 而不是 class_ro_t 中的 baseMethods</li>
</ul>
<h5 id="引伸：分类可以添加那些内容"><a href="#引伸：分类可以添加那些内容" class="headerlink" title="引伸：分类可以添加那些内容"></a>引伸：分类可以添加那些内容</h5><ul>
<li>实例方法，类方法，协议，属性</li>
</ul>
<h5 id="引伸：Category-的实现原理"><a href="#引伸：Category-的实现原理" class="headerlink" title="引伸：Category 的实现原理"></a>引伸：Category 的实现原理</h5><ul>
<li>Category 在刚刚编译完成的时候， 和原来的类是分开的，只有在程序运行起来的时候， 通过 runtime 合并在一起。</li>
</ul>
<h5 id="引申-使用-runtime-Associate-方法关联的对象，需要在主对象-dealloc-的时候释放么"><a href="#引申-使用-runtime-Associate-方法关联的对象，需要在主对象-dealloc-的时候释放么" class="headerlink" title="引申 使用 runtime Associate 方法关联的对象，需要在主对象 dealloc 的时候释放么"></a>引申 使用 runtime Associate 方法关联的对象，需要在主对象 dealloc 的时候释放么</h5><ul>
<li>不需要，被关联的对象的生命周期内要比对象本身释放晚很多， 它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。</li>
</ul>
<h5 id="引申-能否向编译后得到的类中增加实例变量，-能否向运行时创建的类中添加实力变量"><a href="#引申-能否向编译后得到的类中增加实例变量，-能否向运行时创建的类中添加实力变量" class="headerlink" title="引申 能否向编译后得到的类中增加实例变量， 能否向运行时创建的类中添加实力变量"></a>引申 能否向编译后得到的类中增加实例变量， 能否向运行时创建的类中添加实力变量</h5><ul>
<li>不能再编译后得到的类中增加实例变量。因为编译后的类已经注册在 runtime 中， 类结构体中 objc_ivar_list 实例变量的链表和 objc_ivar_list 实例变量的内存大小已经确定，所以不能向存在的类中添加实例变量</li>
<li>能在运行时创建的类中添加实力变量。调用 class_addIvar 函数</li>
</ul>
<h5 id="引申-主类执行了-foo-方法，分类也执行了-foo-方法，在执行的地方执行了-foo-方法，主类的-foo-会被覆盖么？-如果想只想执行主类的-foo-方法，如何去做"><a href="#引申-主类执行了-foo-方法，分类也执行了-foo-方法，在执行的地方执行了-foo-方法，主类的-foo-会被覆盖么？-如果想只想执行主类的-foo-方法，如何去做" class="headerlink" title="引申 主类执行了 foo 方法，分类也执行了 foo 方法，在执行的地方执行了 foo 方法，主类的 foo 会被覆盖么？    如果想只想执行主类的 foo 方法，如何去做"></a>引申 主类执行了 foo 方法，分类也执行了 foo 方法，在执行的地方执行了 foo 方法，主类的 foo 会被覆盖么？    如果想只想执行主类的 foo 方法，如何去做</h5><ul>
<li>主类的方法被分类的 foo 覆盖了，其实分类并没有覆盖主类的 foo 方法，只是分类的方法排在方法列表前面，主类的方法列表被挤到了后面， 调用的时候会首先找到第一次出现的方法。</li>
<li>如果想要只是执行主类的方法，可逆序遍历方法列表，第一次遍历到的 foo 方法就是主类的方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)foo&#123;   </span><br><span class="line">  [类 invokeOriginalMethod:<span class="keyword">self</span> selector:_cmd];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)invokeOriginalMethod:(<span class="keyword">id</span>)target selector:(SEL)selector &#123;</span><br><span class="line">    uint count;</span><br><span class="line">    Method *list = class_copyMethodList([target <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = count - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Method method = list[i];</span><br><span class="line">        SEL name = method_getName(method);</span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        <span class="keyword">if</span> (name == selector) &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))imp)(target, name);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(list);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="8-load-和-initilze-的调用情况，以及子类的调用顺序问题"><a href="#8-load-和-initilze-的调用情况，以及子类的调用顺序问题" class="headerlink" title="8.  load 和 initilze 的调用情况，以及子类的调用顺序问题"></a>8.  load 和 initilze 的调用情况，以及子类的调用顺序问题</h3><ul>
<li>initialize 这个方法是第一次给某给类发送消息的时候调用，并且只会调用一次。 如果某一个类一直没有被用到，此方法也不会执行。</li>
<li>initialize 先初始化父类， 在初始化子类，子类的 initialize 会覆盖父类的方法。</li>
<li>分类中实现了 initialize 会覆盖本来的 initialize 方法，如果多个分类都执行了 initialize ，那么只是执行最后编译的那个。</li>
</ul>
<hr>
<ul>
<li>load 当程序被加载的时候就会调用， 其加载顺序为， 如果子类实现类 load   先执行父类 -&gt; 在执行子类，而分类的在最后执行。</li>
<li>如果子类不实现 load，父类的 load 就不会被执行。</li>
<li>load 是线程安全的，其内部使用了锁，所以我们应该避免在 load 方法中线程阻塞。</li>
<li>load 在分类中，重写了 load 方法，  不会影响其主类的方法。即不会覆盖本类的 load 方法</li>
<li>当有多个类的时候，每个类的 load 的执行顺序和编译顺序一致。</li>
</ul>
<h3 id="9-什么是线程安全"><a href="#9-什么是线程安全" class="headerlink" title="9. 什么是线程安全"></a>9. 什么是线程安全</h3><ul>
<li>多条线程同时访问一段代码，不会造成数据混乱的情况</li>
</ul>
<h3 id="10-你接触到的项目，哪些场景运用到了线程安全"><a href="#10-你接触到的项目，哪些场景运用到了线程安全" class="headerlink" title="10. 你接触到的项目，哪些场景运用到了线程安全"></a>10. 你接触到的项目，哪些场景运用到了线程安全</h3><p>答： 举例说明，12306 同一列火车的车票， 同一时间段多人抢票！ 如何解决 互斥锁使用格式</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">synchronized(锁对象) &#123; <span class="comment">// 需要锁定的代码  &#125;</span></span><br><span class="line">注意：锁定<span class="number">1</span>份代码只用<span class="number">1</span>把锁，用多把锁是无效的</span><br><span class="line"></span><br><span class="line">Tips: 互斥锁的优缺点</span><br><span class="line">优点：能有效防止因多线程抢夺资源造成的数据安全问题</span><br><span class="line">缺点：需要消耗大量的CPU资源</span><br><span class="line"> </span><br><span class="line">互斥锁的使用前提：多条线程抢夺同一块资源 </span><br><span class="line">相关专业术语：线程同步,多条线程按顺序地执行任务</span><br><span class="line">互斥锁，就是使用了线程同步技术</span><br><span class="line"> </span><br><span class="line">Objective-C中的原子和非原子属性</span><br><span class="line">OC在定义属性时有<span class="keyword">nonatomic</span>和atomic两种选择</span><br><span class="line">atomic：原子属性，为<span class="keyword">setter</span>/<span class="keyword">getter</span>方法都加锁（默认就是atomic）</span><br><span class="line"><span class="keyword">nonatomic</span>：非原子属性，不加锁</span><br><span class="line"> </span><br><span class="line">atomic加锁原理:</span><br><span class="line">property (<span class="keyword">assign</span>, atomic) <span class="keyword">int</span> age;</span><br><span class="line"> - (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;  </span><br><span class="line">       _age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- （<span class="keyword">int</span>）age &#123;</span><br><span class="line">    <span class="keyword">int</span> age1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        age1 = _age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原子和非原子属性的选择</span><br><span class="line"><span class="keyword">nonatomic</span>和atomic对比</span><br><span class="line">atomic：线程安全，需要消耗大量的资源</span><br><span class="line"><span class="keyword">nonatomic</span>：非线程安全，适合内存小的移动设备</span><br><span class="line"> </span><br><span class="line">iOS开发的建议</span><br><span class="line">所有属性都声明为<span class="keyword">nonatomic</span></span><br><span class="line">尽量避免多线程抢夺同一块资源</span><br><span class="line">尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力</span><br><span class="line"></span><br><span class="line">atomic就一定能保证线程安全么？</span><br><span class="line">不能，还需要更深层的锁定机制才可以，因为一个线程在连续多次读取某条属性值的时候，与此同时别的线程也在改写值，这样还是会读取到不同的属性值！  或者 一个线程在获取当前属性的值， 另外一个线程把这个属性释放调了， 有可能造成崩溃</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="11-你实现过单例模式么？-你能用几种实现方案"><a href="#11-你实现过单例模式么？-你能用几种实现方案" class="headerlink" title="11. 你实现过单例模式么？ 你能用几种实现方案"></a>11. 你实现过单例模式么？ 你能用几种实现方案</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 运用GCD:</span><br><span class="line">import <span class="string">"Manager.h"</span></span><br><span class="line">implementation Manager</span><br><span class="line">+ (Manager *)sharedManager &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="keyword">static</span> Manager * sharedManager;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    sharedManager=[[Manager alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> sharedManager;</span><br><span class="line">&#125;</span><br><span class="line">end</span><br><span class="line">注明：<span class="built_in">dispatch_once</span>这个函数，它可以保证整个应用程序生命周期中某段代码只被执行一次！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 不使用GCD的方式:</span><br><span class="line"><span class="keyword">static</span> Manager *manager;</span><br><span class="line">implementation Manager</span><br><span class="line">+ (Manager *)defaultManager &#123;</span><br><span class="line">    <span class="keyword">if</span>(!manager)</span><br><span class="line">        manager=[[<span class="keyword">self</span> allocWithZone:<span class="literal">NULL</span>] init];</span><br><span class="line">    <span class="keyword">return</span>  manager;</span><br><span class="line">&#125;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 正常的完整版本</span><br><span class="line">+(<span class="keyword">id</span>)shareInstance&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">      <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      <span class="keyword">if</span>(_instance == <span class="literal">nil</span>)</span><br><span class="line">            _instance = [MyClass alloc] init]; </span><br><span class="line">    &#125;);</span><br><span class="line">     <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写allocWithZone,里面实现跟方法一,方法二一致就行.</span></span><br><span class="line">+(<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone&#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="keyword">self</span> shareInstance];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//保证copy时相同</span></span><br><span class="line">-(<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123;  </span><br><span class="line">    <span class="keyword">return</span> _instance;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//  方法3创建的目的的是  为了方式开发者在调用单例的时候并没有用shareInstance方法来创建 而是用的alloc  或者copy的形式创建造成单例不一致的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   </span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="引申-1-单例是怎么销毁的"><a href="#引申-1-单例是怎么销毁的" class="headerlink" title="引申 1. 单例是怎么销毁的"></a>引申 1. 单例是怎么销毁的</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须把static dispatch_once_t onceToken; 这个拿到函数体外,成为全局的.</span></span><br><span class="line">+ (<span class="keyword">void</span>)attempDealloc &#123;</span><br><span class="line">    onceToken = <span class="number">0</span>; <span class="comment">// 只有置成0,GCD才会认为它从未执行过.它默认为0,这样才能保证下次再次调用shareInstance的时候,再次创建对象.</span></span><br><span class="line">    _sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_once_t</span> 的工作原理是，<span class="keyword">static</span>修饰会默认将其初始化为<span class="number">0</span>, 当且仅当其为<span class="number">0</span>的时候<span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;&#125;)这个函数才能被调用， 如果执行了这个函数  这个<span class="built_in">dispatch_once_t</span> 静态变成- <span class="number">1</span>了  就永远不会被调用</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="引申-2-不使用-dispatch-once-如何-实现单例"><a href="#引申-2-不使用-dispatch-once-如何-实现单例" class="headerlink" title="引申 2.  不使用 dispatch_once 如何 实现单例"></a>引申 2.  不使用 dispatch_once 如何 实现单例</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>第一种方式,重写+allocWithZone:方法;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123; <span class="comment">// 互斥锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>第二种方式,不用重写+allocWithZone:方法,而是直接用<span class="keyword">@synchronized</span> 来保证线程安全,其它与上面这个方法一样;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedSingleton &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="12-项目开发中，你用单例都做了什么"><a href="#12-项目开发中，你用单例都做了什么" class="headerlink" title="12. 项目开发中，你用单例都做了什么"></a>12. 项目开发中，你用单例都做了什么</h3><p>答 ：整个程序公用一份资源的时候  例如 ：</p>
<blockquote>
<ul>
<li>设置单例类访问应用的配置信息</li>
<li>用户的个人信息登录后用的 NSUserDefaults 存储，对登录类进一步采用单例封装方便全局访问</li>
<li>防止一个单例对 应用 多处 对同意本地数据库存进行操作</li>
</ul>
</blockquote>
<hr>
<h3 id="13-APNS-的基本原理"><a href="#13-APNS-的基本原理" class="headerlink" title="13.APNS 的基本原理"></a>13.APNS 的基本原理</h3><ul>
<li><p>基本</p>
<blockquote>
<ul>
<li>第一阶段：应用程序的服务器端把要发送的消息、目的 iPhone 的标识打包，发给 APNS。</li>
<li>第二阶段：APNS 在自身的已注册 Push 服务的 iPhone 列表中，查找有相应标识的 iPhone，并把消息发送到 iPhone。</li>
<li>第三阶段：iPhone 把发来的消息传递给相应的应用程序，并且按照设定弹出 Push 通知。</li>
</ul>
</blockquote>
</li>
<li><p>详细说明 </p>
</li>
</ul>
<p><strong>首先是注册</strong></p>
<blockquote>
<ul>
<li>Device（设备）连接 APNs 服务器并携带设备序列号（UUID）</li>
<li>连接成功，APNs 经过打包和处理产生 devicetoken 并返回给注册的 Device（设备）</li>
<li>Device（设备）携带获取的 devicetoken 发送到我们自己的应用服务器</li>
<li>完成需要被推送的 Device（设备）在 APNs 服务器和我们自己的应用服务器的注册</li>
</ul>
</blockquote>
<p><strong>推送过程</strong></p>
<blockquote>
<ul>
<li>1、首先手机装有当前的 app，并且保持有网络的情况下，APNs 服务器会验证 devicetoken,成功那个之后会处于一个长连接。 <strong>（这里会有面试问？ 如果 app 也注册成功了， 也下载了，也同意了打开推送功能， 这个时候在把 App 删除了， 还能接受推送了么？ ）</strong></li>
<li>2、当我们推送消息的时候，我们的服务器按照指定格式进行打包，结合 devicetoken 一起发送给 APNs 服务器，</li>
<li>3、APNs 服务器将新消息推送到 iOS 设备上，然后在设备屏幕上显示出推送的消息。</li>
<li>4、iOS 设备收到推送消息后， 会通知给我们的应用程序并给予提示</li>
</ul>
</blockquote>
<p>// 推送过程如下图</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;652&quot; height=&quot;110&quot;&gt;&lt;/svg" alt="Alt text"></p>
<h3 id="14-RunLoop-的基础知识"><a href="#14-RunLoop-的基础知识" class="headerlink" title="14. RunLoop 的基础知识"></a>14. RunLoop 的基础知识</h3><ul>
<li>RunLoop 模式有哪些？</li>
</ul>
<p>答 ： iOS 中有五种 RunLoop 模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSDefaultRunLoopMode (默认模式，有事件响应的时候，会阻塞旧事件)</span><br><span class="line">NSRunLoopCommonModes (普通模式，不会影响任何事件)</span><br><span class="line">UITrackingRunLoopMode （只能是有事件的时候才会响应的模式）</span><br><span class="line"></span><br><span class="line">还有两种系统级别的模式</span><br><span class="line">一个是app刚启动的时候会执行一次</span><br><span class="line">另外一个是系统检测app各种事件的模式</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>RunLoop 的基本执行原理</li>
</ul>
<p>答 ： 原本系统就有一个 runloop 在检测 App 内部的行为或事件，当输入源（用户的直接或者间接的操作）有“执行操作”的时候， 系统的 runloop 会监听输入源的状态， 进而在系统内部做一些对应的相应操作。   处理完成后，会自动回到睡眠状态， 等待下一次被唤醒，</p>
<ul>
<li>RunLoop 和线程的关系</li>
<li>RunLoop 的作用就是用来管理线程的， 当线程的 RunLoop 开启之后，线程就会在执行完成任务后，进入休眠状态，随时等待接收新的任务，而不是退出。</li>
<li>为什么只有主线程的<code>runloop</code>是开启的</li>
<li>程序开启之后，要一直运行，不会退出。 说白了就是为了让程序不死</li>
</ul>
<hr>
<h4 id="如何保证一个线程永远不死-常驻线程"><a href="#如何保证一个线程永远不死-常驻线程" class="headerlink" title="如何保证一个线程永远不死(常驻线程)"></a>如何保证一个线程永远不死(常驻线程)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 先创建一个线程用于测试</span></span><br><span class="line">     <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]  initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(play) object:<span class="literal">nil</span>];</span><br><span class="line">    [thread start];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证一个线程永远不死</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[<span class="built_in">NSPort</span> port] -forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在合适的地方处理线程的事件处理</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="15-weak-属性"><a href="#15-weak-属性" class="headerlink" title="15. weak 属性"></a>15. weak 属性</h3><ol>
<li>说说你理解 weak 属性?</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>实现<span class="keyword">weak</span>后，为什么对象释放后会自动为<span class="literal">nil</span>？</span><br><span class="line"></span><br><span class="line">runtime 对注册的类， 会进行布局，</span><br><span class="line">对于 <span class="keyword">weak</span> 对象会放入一个 hash 表中。 </span><br><span class="line">用 <span class="keyword">weak</span> 指向的对象内存地址作为 key，</span><br><span class="line">Value是<span class="keyword">weak</span>指针的地址数组。</span><br><span class="line">当释放的时候，其内部会通过当前的key找到所有的<span class="keyword">weak</span>指针指向的数组</span><br><span class="line">然后遍历这个数组把其中的数据设置为<span class="literal">nil</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">稍微详细的说：在内部底层源码也同时和当前对象相关联得SideTable， 其内部有三个属性， 一个是一把自旋锁，一个是引用计数器相关，一个是维护<span class="keyword">weak</span>生命得属性得表</span><br><span class="line">**SideTable**这个结构体一样的东西，可以花半个小时看一眼。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h4><ul>
<li>objc 中向一个 nil 对象发送消息将会发生什么？ 首先 在寻找对象化的 isa 指针时就是 0 地址返回了， 所以不会有任何错误， 也不会错误</li>
<li>objc 在向一个对象发送消息时，发生了什么？</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  - 首先是通过obj 的isa指针找到对应的<span class="keyword">class</span></span><br><span class="line">  - 先去操作对象中的缓存方法列表中objc_cache中去寻找 当前方法，如果找到就直接实现对应IMP</span><br><span class="line">  - 如果在缓存中找不到，则在<span class="keyword">class</span>中找到对用的Method list中对用foo</span><br><span class="line">  - 如果<span class="keyword">class</span>中没有找到对应的foo， 就会去superClass中去找</span><br><span class="line">  - 如果找到了对应的foo， 就会实现foo对应的IMP</span><br><span class="line"></span><br><span class="line">  缓存方法列表， 就是每次执行这个方法的时候都会做如此繁琐的操作这样太过于消耗性能，所以出现了一个objc_cache，这个会把当前调用过的类中的方法做一个缓存， 当前method_name作为key， method_IMP作为Value，当再一次接收到消息的时候，直接通过objc_cache去找到对应的foo的IMP即可， 避免每一次都去遍历objc_method_list</span><br><span class="line"></span><br><span class="line">如果一直没有找到方法， 就会专用消息转发机制，机制如下</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法解析和转发</span></span><br><span class="line">上面的例子如果foo函数一直没有被找到，通常情况下，会出现报错，但是在报错之前，OC的运行时给了我们三次补救的机会</span><br><span class="line"></span><br><span class="line">- Method resolution</span><br><span class="line">- Fast forwarding</span><br><span class="line">- Normal forwarding</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span> Runtime 会发送 +resolveInstanceMethod: 或者 +resolveClassMethod: 尝试去 resolve(重启) 这个消息；</span><br><span class="line"><span class="number">2.</span> 如果 resolve 方法返回 <span class="literal">NO</span>，Runtime 就发送 -forwardingTargetForSelector: 允许你把这个消息转发给另一个对象；</span><br><span class="line"><span class="number">3.</span> 如果没有新的目标对象返回， Runtime 就会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。你可以发送 -invokeWithTarget: 消息来手动转发消息或者发送 -doesNotRecognizeSelector: 抛出异常。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="16-UIView-和-CALayer-是什么关系"><a href="#16-UIView-和-CALayer-是什么关系" class="headerlink" title="16.UIView 和 CALayer 是什么关系"></a>16.UIView 和 CALayer 是什么关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    - 两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以；</span><br><span class="line">    - 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</span><br><span class="line">    - 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display </span><br><span class="line">CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</span><br><span class="line">    - layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="16-synthesize-和-dynamic-分别有什么作用"><a href="#16-synthesize-和-dynamic-分别有什么作用" class="headerlink" title="16.  @synthesize 和 @dynamic 分别有什么作用"></a>16.  @synthesize 和 @dynamic 分别有什么作用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;</span><br><span class="line">- @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</span><br><span class="line"></span><br><span class="line">- @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="17-static-有什么作用"><a href="#17-static-有什么作用" class="headerlink" title="17.  static 有什么作用"></a>17.  static 有什么作用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static关键字可以修饰函数和变量，作用如下：</span><br><span class="line"></span><br><span class="line">**隐藏**</span><br><span class="line"></span><br><span class="line">通过static修饰的函数或者变量，在该文件中，所有位于这条语句之后的函数都可以访问，而其他文件中的方法和函数则不行</span><br><span class="line"></span><br><span class="line">**静态变量**</span><br><span class="line"></span><br><span class="line">类方法不可以访问实例变量（函数），通过static修饰的实例变量（函数），可以被类   方法访问；</span><br><span class="line"></span><br><span class="line">**持久**</span><br><span class="line"></span><br><span class="line">static修饰的变量，能且只能被初始化一次；</span><br><span class="line"></span><br><span class="line">**默认初始化**</span><br><span class="line"></span><br><span class="line">static修饰的变量，默认初始化为0；</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="18-objc-在向一个对象发送消息时，发生了什么"><a href="#18-objc-在向一个对象发送消息时，发生了什么" class="headerlink" title="18. objc 在向一个对象发送消息时，发生了什么"></a>18. objc 在向一个对象发送消息时，发生了什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- objc_msgSend(recicver, selecter..)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="19-runloop-是来做什么的？runloop-和线程有什么关系？主线程默认开启了-runloop-么？子线程呢"><a href="#19-runloop-是来做什么的？runloop-和线程有什么关系？主线程默认开启了-runloop-么？子线程呢" class="headerlink" title="19. runloop 是来做什么的？runloop 和线程有什么关系？主线程默认开启了 runloop 么？子线程呢"></a>19. runloop 是来做什么的？runloop 和线程有什么关系？主线程默认开启了 runloop 么？子线程呢</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. runloop与线程是一一对应的，一个runloop对应一个核心的线程，为什么说是核心的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里。</span><br><span class="line">2. runloop是来管理线程的，当线程的runloop被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。runloop在第一次获取时被创建，在线程结束时被销毁。</span><br><span class="line">3. 对于主线程来说，runloop在程序一启动就默认创建好了。</span><br><span class="line">4. 对于子线程来说， runloop是懒加载的，只有当我们使用的时候才会创建，所以在子线程用定时器要注意：确保子线程的runloop被开启，不然定时器不会回调。   </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="20-如何手动触发一个-value-的-KVO"><a href="#20-如何手动触发一个-value-的-KVO" class="headerlink" title="20. 如何手动触发一个 value 的 KVO"></a>20. 如何手动触发一个 value 的 KVO</h3><p>键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey: 。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， didChangeValueForKey: 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。</p>
<h4 id="引申-0-如何给系统-KVO-设置筛选条件"><a href="#引申-0-如何给系统-KVO-设置筛选条件" class="headerlink" title="引申 0 如何给系统 KVO 设置筛选条件"></a>引申 0 如何给系统 KVO 设置筛选条件</h4><ul>
<li>举例：取消 Person 类 age 属性的默认 KVO，设置 age 大于 18 时，手动触发 KVO</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"age"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSInteger</span>)age &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">        _age = age;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        _age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="引申-1-通过-KVC-修改属性会触发-KVO-么？直接修改成员变量呢"><a href="#引申-1-通过-KVC-修改属性会触发-KVO-么？直接修改成员变量呢" class="headerlink" title="引申  1.通过 KVC 修改属性会触发 KVO 么？直接修改成员变量呢"></a>引申  1.通过 KVC 修改属性会触发 KVO 么？直接修改成员变量呢</h4><ul>
<li>会触发 KVO。即使没有声明属性，只有成员变量，只要 accessInstanceVariablesDirectly 返回的是 YES，允许访问其成员变量，那么不管有没有调用 setter 方法，通过 KVC 修改成员变量的值，都能触发 KVO。这也说明通过 KVC 内部实现了 willChangeValueForKey:方法和 didChangeValueForKey:方法</li>
<li>直接修改成员变量不会触发 KVO。直接修改成员变量内部并没有做处理只是单纯的赋值，所以不会触发。</li>
</ul>
<h4 id="引申-kvc-的底层实现"><a href="#引申-kvc-的底层实现" class="headerlink" title="引申  kvc 的底层实现"></a>引申  kvc 的底层实现</h4><ul>
<li><strong>赋值方法 setValue:forKey:的原理</strong></li>
</ul>
<p>（1）首先会按照顺序依次查找 setKey:方法和_setKey:方法，只要找到这两个方法当中的任何一个就直接传递参数，调用方法；</p>
<p>（2）如果没有找到 setKey:和_setKey:方法，那么这个时候会查看 accessInstanceVariablesDirectly 方法的返回值，如果返回的是 NO（也就是不允许直接访问成员变量），那么会调用 setValue:forUndefineKey:方法，并抛出异常“NSUnknownKeyException”；</p>
<p>（3）如果 accessInstanceVariablesDirectly 方法返回的是 YES，也就是说可以访问其成员变量，那么就会按照顺序依次查找 _key、_isKey、key、isKey 这四个成员变量，如果查找到了，就直接赋值；如果依然没有查到，那么会调用 setValue:forUndefineKey:方法，并抛出异常“NSUnknownKeyException”。</p>
<ul>
<li><strong>取值方法 valueForKey:的原理</strong></li>
</ul>
<p>（1）首先会按照顺序依次查找 getKey:、key、isKey、_key:这四个方法，只要找到这四个方法当中的任何一个就直接调用该方法；</p>
<p>（2）如果没有找到，那么这个时候会查看 accessInstanceVariablesDirectly 方法的返回值，如果返回的是 NO（也就是不允许直接访问成员变量），那么会调用 valueforUndefineKey:方法，并抛出异常“NSUnknownKeyException”；</p>
<p>（3）如果 accessInstanceVariablesDirectly 方法返回的是 YES，也就是说可以访问其成员变量，那么就会按照顺序依次查找 _key、_isKey、key、isKey 这四个成员变量，如果找到了，就直接取值；如果依然没有找到成员变量，那么会调用 valueforUndefineKey 方法，并抛出异常“NSUnknownKeyException”。</p>
<h3 id="21-ViewController-生命周期"><a href="#21-ViewController-生命周期" class="headerlink" title="21. ViewController 生命周期"></a>21. ViewController 生命周期</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">按照执行顺序排列：</span><br><span class="line"><span class="number">1.</span> initWithCoder：通过nib文件初始化时触发。</span><br><span class="line"><span class="number">2.</span> awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。      </span><br><span class="line"><span class="number">3.</span> loadView：开始加载视图控制器自带的view。</span><br><span class="line"><span class="number">4.</span> viewDidLoad：视图控制器的view被加载完成。  </span><br><span class="line"><span class="number">5.</span> viewWillAppear：视图控制器的view将要显示在window上。</span><br><span class="line"><span class="number">6.</span> updateViewConstraints：视图控制器的view开始更新AutoLayout约束。</span><br><span class="line"><span class="number">7.</span> viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。</span><br><span class="line"><span class="number">8.</span> viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。</span><br><span class="line"><span class="number">9.</span> viewDidAppear：视图控制器的view已经展示到window上。 </span><br><span class="line"><span class="number">10.</span> viewWillDisappear：视图控制器的view将要从window上消失。</span><br><span class="line"><span class="number">11.</span> viewDidDisappear：视图控制器的view已经从window上消失。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="22-网络协议"><a href="#22-网络协议" class="headerlink" title="22.网络协议"></a>22.网络协议</h3><ul>
<li>TCP 三次握手和四次挥手？</li>
</ul>
<p><strong>三次握手</strong></p>
<blockquote>
<p><strong>1.</strong>客户端向服务端发起请求链接，首先发送 SYN 报文，SYN=1，seq=x,并且客户端进入 SYN_SENT 状态 <strong>2.</strong>服务端收到请求链接，服务端向客户端进行回复，并发送响应报文，SYN=1，seq=y,ACK=1,ack=x+1,并且服务端进入到 SYN_RCVD 状态 <strong>3.</strong>客户端收到确认报文后，向服务端发送确认报文，ACK=1，ack=y+1，此时客户端进入到 ESTABLISHED，服务端收到用户端发送过来的确认报文后，也进入到 ESTABLISHED 状态，此时链接创建成功</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; - 哎！</span><br><span class="line">&gt; - 嗯</span><br><span class="line">&gt; - 给你 </span><br><span class="line">&gt; 复制代码</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>为什么需要三次握手：</strong> 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。假设这是一个早已失效的报文段，但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。</p>
</blockquote>
<p><strong>四次挥手</strong></p>
<blockquote>
<p><strong>1.</strong>客户端向服务端发起关闭链接，并停止发送数据 <strong>2.</strong>服务端收到关闭链接的请求时，向客户端发送回应，我知道了，然后停止接收数据 <strong>3.</strong>当服务端发送数据结束之后，向客户端发起关闭链接，并停止发送数据 <strong>4.</strong>客户端收到关闭链接的请求时，向服务端发送回应，我知道了，然后停止接收数据</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 哎！</span><br><span class="line">- 嗯</span><br><span class="line">- 关了</span><br><span class="line">- 好的</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>为什么需要四次挥手：</strong> 因为 TCP 是全双工通信的，在接收到客户端的关闭请求时，还可能在向客户端发送着数据，因此不能再回应关闭链接的请求时，同时发送关闭链接的请求</p>
<h4 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h4><ol>
<li>HTTP 和 HTTPS 有什么区别？<ul>
<li>HTTP 协议是一种使用<strong>明文</strong>数据传输的网络协议。</li>
<li>HTTPS 协议可以理解为 HTTP 协议的升级，就是在 HTTP 的基础上增加了数据加密。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息让然是安全的。这就是 HTTP 和 HTTPS 的最大区别。</li>
</ul>
</li>
<li>HTTPS 的加密方式？<ul>
<li>Https 采用对称加密和非对称加密结合的方式来进行通信。</li>
<li>Https 不是应用层的新协议，而是 Http 通信接口用 SSL 和 TLS 来加强加密和认证机制。<ul>
<li>对称加密： 加密和解密都是同一个钥匙</li>
<li>非对称加密：密钥承兑出现，分为公钥和私钥，公钥加密需要私钥解密，私钥加密需要公钥解密</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="HTTP-和-HTTPS-的建立连接的过程"><a href="#HTTP-和-HTTPS-的建立连接的过程" class="headerlink" title="HTTP 和 HTTPS 的建立连接的过程"></a>HTTP 和 HTTPS 的建立连接的过程</h4><p><strong>HTTP</strong></p>
<ul>
<li>建立链接完毕以后客户端会发送响应给服务器</li>
<li>服务端接受请求并且做出响应发送给客户端</li>
<li>客户端收到响应并且解析响应给客户</li>
</ul>
<p><strong>HTTPS</strong> </p>
<ul>
<li>在使用 HTTPS 是需要保证服务端配置了正确的对应的安全证书</li>
<li>客户端发送请求到服务器</li>
<li>服务端返回公钥和证书到客户端</li>
<li>客户端接受后，会验证证书的安全性，如果通过则会随机生成一个随机数，用公钥对其解密， 发送到服务端</li>
<li>服务端接受到这个加密后的随机数后，会用私钥对其进行揭秘，得到真正的随机数，然后调用这个随机数当作私钥对需要发送的数据进行对称加密。</li>
<li>客户端接收到加密后的数据使用私钥（之前生成的随机值）对数据进行解密，并且解析数据呈现给客户</li>
</ul>
<h4 id="HTTP-协议中-GET-和-POST-的区别"><a href="#HTTP-协议中-GET-和-POST-的区别" class="headerlink" title="HTTP 协议中 GET 和 POST 的区别"></a>HTTP 协议中 GET 和 POST 的区别</h4><ul>
<li>GET 在<strong>特定的浏览器和服务器</strong>对 URL 的长度是有限制的。 但是理论上是没有限制的</li>
<li>POST 不是通过 URL 进行传值，理论上不受限制。</li>
<li>GET 会把请求参数拼接到 URL 后面， 不安全，</li>
<li>POST 把参数放到请求体里面， 会比 GET 相对安全一点， 但是由于可以窥探数据， 所以也不安全， 想更安全用加密。</li>
<li>GET 比 POST 的请求速度快。原因：Post 请求的过程， 会现将请求头发送给服务器确认，然后才真正的发送数据， 而 Get 请求 过程会在链接建立后会将请求头和数据一起发送给服务器。 中间少了一步。 所以 get 比 post 快</li>
<li>post 的请求过程</li>
<li>三次握手之后 <strong>第三次会把 post 请求头发送</strong></li>
<li>服务器返回 100 continue 响应</li>
<li>浏览器开始发送数据</li>
<li>服务器返回 200 ok 响应</li>
</ul>
<hr>
<ul>
<li>get 请求过程</li>
<li>三次握手之后 <strong>第三次会发送 get 请求头和数据</strong></li>
<li>服务器返回 200 ok 响应</li>
</ul>
<h3 id="23-有没有使用过-performSelector"><a href="#23-有没有使用过-performSelector" class="headerlink" title="23.  有没有使用过 performSelector"></a>23.  有没有使用过 performSelector</h3><ul>
<li>这题主要是想问的是有没有动态添加过方法</li>
<li>话不多说上代码</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span></span><br><span class="line">    <span class="comment">// 动态添加方法就不会报错</span></span><br><span class="line">    [p performSelector:<span class="keyword">@selector</span>(eat)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// **这里真是奇葩， 实在想不到什么时候才有这种使用场景， 我再外面找不到方法， 我再当前类里面直接在写一个方法就好咯，干嘛要在这里写这个玩意， 还要写一个C语言的东西， 既然面试想问， 那咱就要会！**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void(*)()</span></span><br><span class="line"><span class="comment">// 默认方法都有两个隐式参数，</span></span><br><span class="line"><span class="keyword">void</span> eat(<span class="keyword">id</span> <span class="keyword">self</span>,SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,<span class="keyword">self</span>,<span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></span><br><span class="line"><span class="comment">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</span><br><span class="line">        <span class="comment">// 动态添加eat方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个参数：给哪个类添加方法</span></span><br><span class="line">        <span class="comment">// 第二个参数：添加方法的方法编号</span></span><br><span class="line">        <span class="comment">// 第三个参数：添加方法的函数实现（函数地址）</span></span><br><span class="line">        <span class="comment">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(eat), eat, <span class="string">"v@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>当然面试的时候也可能问你这个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 延时操作 和GCD的after 一个效果</span><br><span class="line">[p performSelector:@selector(eat) withObject:nil afterDelay:4];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>你以为完了？ 错了，大概率面试官会问你，<strong>* 上面这段代码放在子线程中 是什么样子的？为什么？</strong></p>
<p>—首先 上面这个方法其实就是内部创建了一个 NSTimer 定时器，然后这个定时器会添加在当前的 RunLoop 中所以上面代码放到子线程中不会有任何定时器相关方法被执行，如果想要执行，开启当前线程即可 即</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">复制代码</span><br><span class="line"><span class="comment">// 完整调用</span></span><br><span class="line"> <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">//  [[NSRunLoop currentRunLoop] run]; 放在上面执行时不可以的，因为当前只是开启了runloop 里面没有任何事件（source，timer，observer）也是开启失败的</span></span><br><span class="line">         [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2</span>];</span><br><span class="line">         [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由此我自行又做了一个测试， 把        </span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test)];</span><br><span class="line">在子线程调用，是没有任何问题的。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我又测试了一下，</span></span><br><span class="line"> [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2</span>];</span><br><span class="line"> 这个方法在主线程执行  打印线程是<span class="number">1</span></span><br><span class="line"></span><br><span class="line">在子线程中调用打印线程 非<span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>然后面试官开始飘了， 开始问你关于 NSTimer 相关问题？怎么办？ 答：  <strong><em>搞他！\</em></strong></li>
</ul>
<h4 id="引申-NSTimer-在子线程执行"><a href="#引申-NSTimer-在子线程执行" class="headerlink" title="引申 NSTimer 在子线程执行"></a>引申 NSTimer 在子线程执行</h4><ul>
<li>NSTimer 直接在在子线程是不会被调用的， 想要执行请开启当前的 Runloop 。具体开启方案上面题有说，不赘述。</li>
</ul>
<h4 id="引申-为什么说-NSTimer-不准确"><a href="#引申-为什么说-NSTimer-不准确" class="headerlink" title="引申 为什么说 NSTimer 不准确"></a>引申 为什么说 NSTimer 不准确</h4><ul>
<li>NSTimer 的触发时间到的时候，runloop 如果在阻塞状态，触发时间就会推迟到下一个 runloop 周期 <strong><em>减少误差的方法 代码如下\</em></strong> </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子线程中开启NStimer，或者更改当前Runloop的Mode 为NSRunLoopCommonModes</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop]addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用CADisplayLink （iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高）</span></span><br><span class="line"><span class="built_in">CADisplayLink</span> *displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(logInfo)];</span><br><span class="line">[displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用GCD</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> interval = <span class="number">1.0</span>;</span><br><span class="line">_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>));</span><br><span class="line">dispatch_source_set_timer(_timer, dispatch_walltime(<span class="literal">NULL</span>, <span class="number">0</span>), interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"GCD timer test"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(_timer);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="引申：-NStimer-的循环引用"><a href="#引申：-NStimer-的循环引用" class="headerlink" title="引申： NStimer 的循环引用"></a>引申： NStimer 的循环引用</h4><ul>
<li>很多朋友因为这个面试题会被面试官怀疑能力问题（给别有用心的人看，祝福你身体健全，生孩子四肢正常）话不多说，说我的理解。</li>
<li>有的人会说， NSTimer 本身的 target 会引用这 self， 而 self 又引用这 Timer 就造成了循环引用， 那如果 timer 用 weak 声明呢？ 还会循环引用么？ 答案：会的</li>
<li>原因是 NTtimer 和 Runloop 是一个相互存在的东西， 别的道理我就不多 BB， 就是 Runloop 和 tmier 相互引用，而 Runloop 永远不会销毁，造成贷方面的“牵引”  所以苹果出来了一个 invalid 的方法。</li>
<li>优化的方案还有别的， 例如利用 NSProxy 这个专门做消息转发的虚类去优化循环引用（这里也经常会被问到。具体方案我不说， 自行百度，切记，如果兄弟你不知道这个玩意，  建议你看看，面试的时候被问到的概率还是挺大的。）</li>
</ul>
<h3 id="24-为什么-AFN3-0-中需要设置-self-operationQueue-maxConcurrentOperationCount-1-而-AF2-0-却不需要"><a href="#24-为什么-AFN3-0-中需要设置-self-operationQueue-maxConcurrentOperationCount-1-而-AF2-0-却不需要" class="headerlink" title="24.  为什么 AFN3.0 中需要设置 self.operationQueue.maxConcurrentOperationCount = 1;而 AF2.0 却不需要"></a>24.  为什么 AFN3.0 中需要设置 self.operationQueue.maxConcurrentOperationCount = 1;而 AF2.0 却不需要</h3><ul>
<li>功能不一样， 2.x 是基于 NSURLConnection 的，其内部实现要在异步并发，所以不能设置 1。 3.0 是基于 NSURLSession 其内部是需要串行的鉴于一些多线程数据访问的安全性考虑， 设置这个达到串行回调的效果。</li>
</ul>
<h4 id="AFNetworking-2-0-和-3-0-的区别"><a href="#AFNetworking-2-0-和-3-0-的区别" class="headerlink" title="AFNetworking 2.0 和 3.0 的区别"></a>AFNetworking 2.0 和 3.0 的区别</h4><ul>
<li>AFN3.0 剔除了所有的 NSURLConnection 请求的 API</li>
<li>AFN3.0 使用 NSOperationQueue 代替 AFN2.0 的常驻线程</li>
</ul>
<h4 id="2-x-版本常驻线程的分析"><a href="#2-x-版本常驻线程的分析" class="headerlink" title="2.x 版本常驻线程的分析"></a>2.x 版本常驻线程的分析</h4><ul>
<li>在请求完成后我们需要对数据进行一些序列化处理，或者错误处理。如果我们在主线中处理这些事情很明显是不合理的。不仅会导致 UI 的卡顿，甚至受到默认的 RunLoopModel 的影响，我们在滑动 tableview 的时候，会导致时间的处理停止。</li>
<li>这里时候我们就需要一个子线程来处理事件和网络请求的回调了。但是，子线程在处理完事件后就会自动结束生命周期，这个时候后面的一些网络请求得回调我们就无法接收了。所以我们就需要开启子线程的 RunLoop 来保存线程的常驻。</li>
<li>当然我们可以每次发起一个请求就开启一条子线程，但是这个想一下就知道开销有多大了。所以这个时候保活一条线程来对请求得回调处理是比较好的一个方案。</li>
</ul>
<h4 id="3-x-版本不在常驻线程的分析"><a href="#3-x-版本不在常驻线程的分析" class="headerlink" title="3.x 版本不在常驻线程的分析"></a>3.x 版本不在常驻线程的分析</h4><ul>
<li>在 3.x 的 AFN 版本中使用的是 NSURLSession 进行封装。对比于 NSURLConnection，NSURLSession 不需要在当前的线程等待网络回调，而是可以让开发者自己设定需要回调的队列。</li>
<li>所以在 3.x 版本中 AFN 使用了 NSOperationQueue 对网络回调的管理，并且设置 maxConcurrentOperationCount 为 1，保证了最大的并发数为 1，也就是说让网络请求串行执行。避免了多线程环境下的资源抢夺问题。</li>
</ul>
<h3 id="25-autoreleasePool-在何时被释放"><a href="#25-autoreleasePool-在何时被释放" class="headerlink" title="25. autoreleasePool 在何时被释放"></a>25. autoreleasePool 在何时被释放</h3><ul>
<li>ARC 中所有的新生对象都是 自动加 autorelese 的， @atuorelesepool 大部分时候解决了瞬时内存暴增的问题 。</li>
<li>MRC 中的情况 关键词变了 NSAutoreleasePool。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来自Apple文档，见参考</span></span><br><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123; </span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123; </span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:urlencoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果循环次数非常多，而且循环体里面的对象都是临时创建使用的，就可以用@autoreleasepool 包起来，让每次循环结束时，可以及时释放临时对象的内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for 和 for in 里面是没有自动包装@autoreleasepool着的，而下面的方法是由@autoreleasepool自动包围的</span></span><br><span class="line">[array enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="comment">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class="line">&#125;];</span><br><span class="line">复制代码</span><br><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="built_in">NSString</span>* str = [[[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"666"</span>] autorelease];</span><br><span class="line">[pool drain];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其作用于为drain 和 init 之间</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>回归正题@autoReleasePool 什么时间释放?<ul>
<li>一个被 autoreleasepool 包裹生成得对象，都会在其创建生成之后自动添加 autorelease， 然后被 autorelease 对象得释放时机 就是在当前 runloop 循环结束的时候自动释放的 </li>
<li>参考链接：<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">blog.sunnyxx.com/2014/10/15/……</a></li>
</ul>
</li>
</ul>
<h4 id="子线程中的-autorelease-变量什么时候释放"><a href="#子线程中的-autorelease-变量什么时候释放" class="headerlink" title="子线程中的 autorelease 变量什么时候释放"></a>子线程中的 autorelease 变量什么时候释放</h4><ul>
<li>子线程中会默认包裹一个 autoreleasepool 的，  释放时机是当前线程退出的时候。</li>
</ul>
<h4 id="autoreleasepool-是如何实现的"><a href="#autoreleasepool-是如何实现的" class="headerlink" title="autoreleasepool 是如何实现的"></a>autoreleasepool 是如何实现的</h4><ul>
<li>@autoreleasepool{} 本质上是一个结构体：</li>
<li>autoreleasepool 会被转换成__AtAutoreleasePool </li>
<li>__AtAutoreleasePool 里面有两个函数<strong>objc_autoreleasePoolPush(),objc_autoreleasePoolPop().</strong>，其实一些列下来之后实际上调用得是 AutoreleasePoolPage 类中得 push 和 pop 两个类方法</li>
<li>push 就是压栈操作，</li>
<li>pop 就是出栈操作于此同时对其对象发送 release 消息进行释放</li>
</ul>
<p>###26. iOS 界面渲染机制？ [这是很大的一个模块，里面牵扯很多东西， 耐心看下去]</p>
<ul>
<li>先简单解释一下渲染机制</li>
</ul>
<p>首先 iOS 渲染视图的核心是 Core Animation，其渲染层次依次为：<strong>图层树-&gt;呈现树-&gt;渲染树</strong> </p>
<ul>
<li>一共三个阶段</li>
<li>CPU 阶段（进行 Frame 布局，准备视图和图层之间的层级关系）</li>
<li>OpenGL ES 阶段(iOS8 以后改成 Metal)， （渲染服务把上面提供的图层上色，生成各种帧）</li>
<li>GPU 阶段 （把上面操作的东西进行一些列的操作，最终展示到屏幕上面）</li>
<li>稍微详细说明</li>
<li>首先一个视图由 CPU 进行 Frame 布局，准备视图和图层的层及关系。</li>
<li>CUP 会将处理视图和图层的层级关系打包，通过 IPC（进程间的通信）通道提交给渲染服务（OpenGL 和 GPU）</li>
<li>渲染服务首先将图层交给 OpenGL 进行纹理生成和着色，生成前后帧缓存，再根据硬件的刷新帧率，一般以设备的 VSync 信号和 CADisplayLink（类似一个刷新 UI 专用的定时器）为标准，进行前后帧缓存的切换</li>
<li>最后，将最终 要显示在画面上的后帧缓存交给 GPU，进行采集图片和形状，运行变换， 应用纹理混合，最终显示在屏幕上。</li>
</ul>
<h4 id="程序卡顿的原因"><a href="#程序卡顿的原因" class="headerlink" title="程序卡顿的原因"></a>程序卡顿的原因</h4><ul>
<li>正常渲染流程</li>
<li>CPU 计算完成之后交给 GPU，来个同步信号 Vsync 将内容渲染到屏幕上</li>
<li>非正常（卡顿/掉帧）的流程</li>
<li>CPU 计算时间正常或者慢，GPU 渲染时间长了， 这时候 Vsync 信号， 由于没有绘制完全，CUP 开始计算下一帧，当下一帧正常绘制成功之后，把当前没有绘制完成的帧丢弃， 显示了下一帧，于是这样就造成了卡顿。 <strong>需要注意的是：Vsync 时间间隔是固定的， 比如 60 帧率大的 Vsync 是每 16ms 就执行一个一次，类似定时器一样</strong></li>
</ul>
<p><strong>这里会出现一个面试题！！！</strong> 题目如下：</p>
<ul>
<li>从第一次打开 App 到完全开始展现出 UI，中间发生了什么？ 或者 App 是怎么渲染某一个 View 的？</li>
<li>回答就是上面的稍微详细说明，如果要求更详细， 可以继续深究一下。</li>
</ul>
<p>在科普一下 <strong><em>1.Core Animation\</em></strong> Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。</p>
<p><strong><em>2.CPU 渲染职能\</em></strong></p>
<ul>
<li><strong>布局计算</strong>：如果视图层级过于复杂，当试图呈现或者修改的时候，计算图层帧率就会消耗一部分时间，</li>
<li><strong>视图懒加载</strong>： iOS 只会当视图控制器的视图显示到屏幕上才会加载它，这对内存使用和程序启动时间很有好处，但是当呈现到屏幕之前，按下按钮导致的许多工作都不会被及时响应。比如，控制器从数据局中获取数据， 或者视图从一个 xib 加载，或者涉及 iO 图片显示都会比 CPU 正常操作慢得多。</li>
<li><strong>解压图片</strong>：PNG 或者 JPEG 压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸(通常等同于图片宽 x 长 x 4 个字节)。为了节省内存，iOS 通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对 图层内容赋值的时候(直接或者间接使用 UIImageView )或者把它绘制到 Core Graphics 中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。</li>
<li><strong>Core Graphics 绘制</strong>：如果对视图实现了 drawRect:或 drawLayer:inContext:方法，或者 CALayerDelegate 的 方法，那么在绘制任何东 西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation 必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后， 必须把图片数据通过 IPC 传到渲染服务器。在此基础上，Core Graphics 绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。</li>
<li><strong>图层打包</strong>：当图层被成功打包，发送到渲染服务器之后，CPU 仍然要做如下工作:为了显示 屏幕上的图层，Core Animation 必须对渲染树种的每个可见图层通过 OpenGL 循环 转换成纹理三角板。由于 GPU 并不知晓 Core Animation 图层的任何结构，所以必须 要由 CPU 做这些事情。这里 CPU 涉及的工作和图层个数成正比，所以如果在你的层 级关系中有太多的图层，就会导致 CPU 没一帧的渲染，即使这些事情不是你的应用 程序可控的。</li>
</ul>
<p><strong><em>3.GPU 渲染职能\</em></strong> GPU 会根据生成的前后帧缓存数据，根据实际情况进行合成，其中造成<strong>GPU 渲染负担</strong>的一般是：<strong>离屏渲染，图层混合，延迟加载。</strong></p>
<p><strong>这里又会出现一个面试题！！！</strong> 一个 UIImageView 添加到视图上以后，内部如何渲染到手机上的？</p>
<p>图片显示分为三个步骤： <strong>加载、解码、渲染</strong>、 通常，我们程序员的操作只是加载，至于解码和渲染是由 UIKit 内部进行的。 例如：UIImageView 显示在屏幕上的时候需要 UIImage 对象进行数据源的赋值。而 UIImage 持有的数据是未解码的压缩数据，当赋值的时候，图像数据会被解码变成 RGB 颜色数据，最终渲染到屏幕上。</p>
<hr>
<p><strong>看完上面的又来问题了！</strong> 关于 UITableView 优化的问题？（真他妈子子孙孙无穷尽也~） 先说造成 UITableView 滚动时候卡顿的的原因有哪些？</p>
<ul>
<li>隐式绘制 CGContext</li>
<li>文本 CATextLayer 和 UILabel</li>
<li>光栅化 shouldRasterize</li>
<li>离屏渲染</li>
<li>可伸缩图片</li>
<li>shadowPath</li>
<li>混合和过度绘制</li>
<li>减少图层数量</li>
<li>裁切</li>
<li>对象回收</li>
<li>Core Graphics 绘制</li>
<li>-renderInContext: 方法</li>
</ul>
<hr>
<p><strong>在说关于 UITableView 的优化问题！</strong></p>
<p>基础的</p>
<ul>
<li>重用机制（缓存池）</li>
<li>少用有透明度的 View</li>
<li>尽量避免使用 xib</li>
<li>尽量避免过多的层级结构</li>
<li>iOS8 以后出的预估高度</li>
<li>减少离屏渲染操作（圆角、阴影啥的）</li>
</ul>
<hr>
<ul>
<li><strong><strong> 解释一下为什么减少离屏渲染操作？\</strong></strong></li>
<li>需要创建新的缓冲区</li>
<li><p>整个过程需要多次切换上下文环境， 显示从当前的屏幕切换到离屏，等待离屏渲染结束后，将离屏缓冲区的渲染结果 显示到屏幕有上， 又要将上下文环境从离屏切换到当前屏幕，</p>
</li>
<li><p><strong><strong>那些操作会触发离屏渲染?\</strong></strong></p>
</li>
<li>光栅化 layer.shouldRasterize = YES</li>
<li>遮罩 layer.mask</li>
<li>圆角 layer.maskToBounds = Yes，Layer.cornerRadis 大于 0</li>
<li>阴影 layer.shadowXXX</li>
</ul>
<p>进阶的</p>
<ul>
<li>缓存 cell 的高度（提前计算好 cell 的高度，缓存进当前的模型里面）</li>
<li>异步绘制</li>
<li>滑动的时候，按需加载</li>
</ul>
<p>高阶的</p>
<ul>
<li>你想不到 竟然不推荐用 UILabel。哈哈哈~  至于为什么 看下面的链接吧</li>
</ul>
<p>至于上面的那些基础的，涉及到渲染级别的自己说的时候悠着点，面试官如果想搞你的话，考一考你最上面的那些，CUP 和 GUP，以及 openGL 相关， 在考一下你进程通信 IPC，以及 VSync 信号啥的， 这些东西太鸡儿高深了，没点匠心 这东西还真搞不了，要想研究可以看看 YYKit 的作者写的一篇关于页面流畅的文章：<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">blog.ibireme.com/2015/11/12/……</a></p>
<h4 id="卡顿检测的方法"><a href="#卡顿检测的方法" class="headerlink" title="卡顿检测的方法"></a>卡顿检测的方法</h4><ul>
<li>卡顿就是主线程阻塞的时间问题，可以添加 Observer 到主线程 Runloop 中，通过监听 Runloop 状态切换的耗时，以达到监听卡顿的目的</li>
</ul>
<hr>
<h4 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h4><p>既然都是图形绘制了，那就再研究一下<strong>事件响应链&amp;原理</strong></p>
<p>传统的问法来了：<strong>UIView 和 CALayer 的区别？</strong> 通常我们这样回答：<strong>UIView 可以响应用户事件，而 CALayer 不能处理事件</strong></p>
<hr>
<p>回答这个之前， 先回顾一下另外一个经典面试题：<strong>事件响应链和事件传递？</strong></p>
<p><strong>基本概念：</strong></p>
<ul>
<li><p>响应链： 是由链接在一起的响应者（UIResponse 子类）组成的，一般为第一响应着到 application 对象以及中间所有响应者一起组成的。</p>
</li>
<li><p>事件传递： 获取响应链之后， 将事件由第一响应者网 application 的传递过程</p>
</li>
<li><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;920&quot; height=&quot;468&quot;&gt;&lt;/svg" alt="enter image description here"></p>
</li>
</ul>
<ul>
<li><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736b686bffee3ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="enter image description here"></p>
</li>
</ul>
<ul>
<li><p><strong>事件的分发和传递</strong></p>
</li>
<li><p>当程序中发生触摸事件之后，系统会将事件添加到 UIApplication 管理的一个队列当中</p>
</li>
<li><p>UIApplication 将处于任务队列最前端的事件向下分发 即 UIWindow</p>
</li>
<li><p>UIWindow 将事件向下分发，即 UIView 或者 UIViewController</p>
</li>
<li><p>UIView 首先看自己能否处理这个事件，触摸点是否在自己身上，自己的透明度是否大于 0,01，userInteractionEnabled 是否是 YES， Hidden 实际是 NO，如果这些都满足，那么继续寻找其子视图</p>
</li>
<li><p>遍历子控件，重复上面步骤</p>
</li>
<li><p>如果没有找到，那么自己就是改事件的处理者</p>
</li>
<li><p>如果自己不能处理，那么就不做任何处理  即视为没有合适的 View 能接收处理当前事件，则改事件会被废弃。</p>
</li>
<li><p><strong><em>怎么寻找当前触摸的是哪一个 View?\</em></strong> 下面中两个方法</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方法返回的View是本次点击事件需要的最佳View</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个点是否落在范围内</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>事件传递给控件之后， 就会调用 hitTest:withEvent 方法去寻找更合适的 View，如果当前 View 存在子控件，则在子控件继续调用 hitTest:withEvent 方法判断是否是合适的 View， 如果还不是就一直遍历寻找， 找不到的话直接废弃掉。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为所有的视图类都是继承BaseView</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">   <span class="comment">// 1.判断当前控件能否接收事件</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden == <span class="literal">YES</span> || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">   <span class="comment">// 2. 判断点在不在当前控件</span></span><br><span class="line">   <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event] == <span class="literal">NO</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">   <span class="comment">// 3.从后往前遍历自己的子控件</span></span><br><span class="line">   <span class="built_in">NSInteger</span> count = <span class="keyword">self</span>.subviews.count;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="built_in">UIView</span> *childView = <span class="keyword">self</span>.subviews[I];</span><br><span class="line">       <span class="comment">// 把当前控件上的坐标系转换成子控件上的坐标系</span></span><br><span class="line">      <span class="built_in">CGPoint</span> childP = [<span class="keyword">self</span> convertPoint:point toView:childView];</span><br><span class="line">      <span class="built_in">UIView</span> *fitView = [childView hitTest:childP withEvent:event];</span><br><span class="line">       <span class="keyword">if</span> (fitView) &#123; <span class="comment">// 寻找到最合适的view</span></span><br><span class="line">           <span class="keyword">return</span> fitView;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 循环结束,表示没有比自己更合适的view</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>判断触摸点是否在视图内？</strong></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tableView 加一个 tap 的手势， 点击当前 cell 的位置  哪个事件被响应 为什么？</strong></li>
<li>tap 事件被响应， 因为 tap 事件添加之后，默认是取消当前 tap 以外的所有事件的， 也就是说， tap 事件处于当前响应者链的最顶端， 解决的办法执行 tap 的 delagete， 实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch  </span><br><span class="line">&#123;  </span><br><span class="line">    if([touch.view isKindOfClass:[XXXXcell class]])  </span><br><span class="line">    &#123;  </span><br><span class="line">        return NO;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return YES;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="27-SDWebImage-是怎么做缓存的"><a href="#27-SDWebImage-是怎么做缓存的" class="headerlink" title="27. SDWebImage 是怎么做缓存的"></a>27. SDWebImage 是怎么做缓存的</h3><ul>
<li>首先说，缓存采用了二级 缓存策略。 图片缓存的时候， 在内存有缓存， 在磁盘中也有缓存， 其中<strong>内存缓存是用 NSCache</strong>做的 （下面会有 NSCache 的说明）。 一、如何做缓存的步骤： 0、下载图片 1、将图片缓存在内存中 2、判断图片的格式 png 或 jpeg，将图片转成 NSData 数据 3、获取图片的存储路径， 其中图片的文件名是通过传入 Key 经过 MD5 加密后获得的 4、将图片存在进磁盘中。</li>
</ul>
<p>二、如何获取图片的？ 1、在内存缓存中找 2、如果内存中找不到， 会去默认磁盘目录中寻找， 如果找不到，在去自定义磁盘目录中寻找 3、如果磁盘也找不到就会下载图片 4、获取图片数据之后，  将图片数据从 NSData 转化 UIImage。其中转化根据图片的类型进行转化 5、默认对图片进行解压缩，生成位图图片 6、将位图图片返回</p>
<p>三、图片是如何被解压缩的？ 1、判断图片是否是动态图片，如果是，不能解压缩 2、判断图片是否透明，如果是，不能解压缩 3、判断图片的颜色空间是不是 RGB 如果不是、不能解压缩 4、根据图片的大小创建一个上下文 5、将图片绘制在上下文中 6、从上下文中读取一个不透明的位图图像，该图像就是解压缩后的图像 7、将位图图像返回</p>
<p>####接上说 NSCache</p>
<ul>
<li>这个 NSCache 说白了就是做缓存专用的一个系统类</li>
<li>类似可变字典一样，但是 NSCache 是线程安全的， 系统类自动做好了加锁和释放锁等一系列的操作， 还有一个重要的是如果内存不足的时候 NSCache 会自动释放掉存储的对象，不需要开发者手动干预。</li>
<li>来看一眼 NSCache 提供的属性和相关方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//名称</span><br><span class="line">@property (copy) NSString *name;</span><br><span class="line"></span><br><span class="line">//NSCacheDelegate代理</span><br><span class="line">@property (nullable, assign) id&lt;NSCacheDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">//通过key获取value，类似于字典中通过key取value的操作</span><br><span class="line">- (nullable ObjectType)objectForKey:(KeyType)key;</span><br><span class="line"></span><br><span class="line">//设置key、value</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">设置key、value</span><br><span class="line">cost表示obj这个value对象的占用的消耗？可以自行设置每个需要添加进缓存的对象的cost值</span><br><span class="line">这个值与后面的totalCostLimit对应，如果添加进缓存的cost总值大于totalCostLimit就会自动进行删除</span><br><span class="line">感觉在实际开发中直接使用setObject:forKey:方法就可以解决问题了</span><br><span class="line">*/</span><br><span class="line">- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</span><br><span class="line"></span><br><span class="line">//根据key删除value对象</span><br><span class="line">- (void)removeObjectForKey:(KeyType)key;</span><br><span class="line"></span><br><span class="line">//删除保存的所有的key-value</span><br><span class="line">- (void)removeAllObjects;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">当NSCache缓存的对象的总cost值大于这个值则会自动释放一部分对象直到占用小于该值</span><br><span class="line">非严格限制意味着如果保存的对象超出这个大小也不一定会被删除</span><br><span class="line">这个值就是与前面setObject:forKey:cost:方法对应</span><br><span class="line">*/</span><br><span class="line">@property NSUInteger totalCostLimit;    // limits are imprecise/not strict</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">缓存能够保存的key-value个数的最大数量</span><br><span class="line">当保存的数量大于该值就会被自动释放</span><br><span class="line">非严格限制意味着如果超出了这个数量也不一定会被删除</span><br><span class="line">*/</span><br><span class="line">@property NSUInteger countLimit;    // limits are imprecise/not strict</span><br><span class="line">/*</span><br><span class="line">这个值与NSDiscardableContent协议有关，默认为YES</span><br><span class="line">当一个类实现了该协议，并且这个类的对象不再被使用时意味着可以被释放</span><br><span class="line">*/</span><br><span class="line">@property BOOL evictsObjectsWithDiscardedContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//NSCacheDelegate协议</span><br><span class="line">@protocol NSCacheDelegate &lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line">//上述协议只有这一个方法，缓存中的一个对象即将被删除时被回调</span><br><span class="line">- (void)cache:(NSCache *)cache willEvictObject:(id)obj;</span><br><span class="line">@end**</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>countLimit</strong>注意一下这个属性， 这个属性就是设置最大缓存数量，啥意思呢? 这玩意就和栈差不多， 先进先出（叫什么 FIFO？）原则。比如你 countLimit 设置为 5  那么当你缓存第 6 个对象的时候， 原本第一个就被移除了。 所以这便就有有一个风险，<strong>也可能会是面试点</strong>，为什么，通过 key 去取值的时候，一定要判断一个获取的对象是否为 nil？答：就因为很有可能某些对象被释放（顶）掉了。</p>
<p>又又又可能出现的面试题！<strong>NSCache 里面缓存的对象，在什么场景下会被释放？</strong></p>
<ul>
<li>回答之前，先说一情况，在某 C 中创建了 NSCache 对象，点击手机的 Home 或者任何方式进入后台，会发现 NSCache 中的代理方法被执行了，于是 NSCache 对象会释放掉所有对象，还有的是，如果发生内存警告也会释放掉所有对象。所以， 这道题应该如下这么回答！</li>
<li>NSCache 自身释放了，其中存储的对象也就释放了。</li>
<li>手动调用释放方法 removeObjectForKey、removeAllObjects</li>
<li>缓存对象个数大于 countLimit</li>
<li>缓存总消耗大于 totalCostLimit</li>
<li>程序进入后台</li>
<li>收到内存警告</li>
</ul>
<h4 id="28-SDWebImage-实现原理是什么？-它是如何解决-tableView-的复用时出现图片错乱问题的呢"><a href="#28-SDWebImage-实现原理是什么？-它是如何解决-tableView-的复用时出现图片错乱问题的呢" class="headerlink" title="28.SDWebImage 实现原理是什么？ 它是如何解决 tableView 的复用时出现图片错乱问题的呢"></a>28.SDWebImage 实现原理是什么？ 它是如何解决 tableView 的复用时出现图片错乱问题的呢</h4><ul>
<li>原理如上，</li>
<li>错乱是在 UIImageView+WebCache 文件中这个方法每次都会调用 [self sd_cancelCurrentImageLoad];</li>
</ul>
<p>###29. 为什么刷新 UI 要在主线程操作</p>
<ul>
<li>UIKit 并不是一个线程安全的类，所以涉及多个线程同时对 UI 进行操作会造成影响。</li>
<li>为什么不把 UIKit 框架设置为线程安全呢？</li>
<li>因为线程安全需要加锁，我们都知道加锁就会消耗性能，影响处理速度，影响渲染速度，我们通常自己在写@property 时都会写 nonatomic 来追求高性能高效率。</li>
<li>假设能够异步设置 view 的属性，那我们究竟是希望这些改动能够同时生效，还是按照各自 runloop 的进度去改变这个 view 的属性呢？</li>
<li>假设 UITableView 在其他线程去移除了一个 cell，而在另一个线程却对这个 cell 所在的 index 进行一些操作，这时候可能就会引发 crash。</li>
<li>如果在后台线程移除了一个 view，这个时候 runloop 周期还没有完结，用户在主线程点击了这个“将要”消失的 view，那么究竟该不该响应事件？在哪条线程进行响应？</li>
<li>在 Cocoa Touch 框架中，UIApplication 初始化工作是在主线程进行的。而界面上所有的视图都是在 UIApplication 实例的叶子节点(内存管理角度)，所以所有的手势交互操作都是在主线程上才能响应</li>
</ul>
<h3 id="30-RunTime"><a href="#30-RunTime" class="headerlink" title="30. RunTime"></a>30. RunTime</h3><h4 id="类的结构体"><a href="#类的结构体" class="headerlink" title="类的结构体"></a>类的结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Class也表示一个结构体指针的类型</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="分类结构体"><a href="#分类结构体" class="headerlink" title="分类结构体"></a>分类结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods; // 对象方法</span><br><span class="line">    struct method_list_t *classMethods; // 类方法</span><br><span class="line">    struct protocol_list_t *protocols; // 协议</span><br><span class="line">    struct property_list_t *instanceProperties; // 属性</span><br><span class="line">    // Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="引申-1-class-copyIvarList-与-class-copyPropertyList-的区别"><a href="#引申-1-class-copyIvarList-与-class-copyPropertyList-的区别" class="headerlink" title="引申 1. class_copyIvarList 与 class_copyPropertyList 的区别"></a>引申 1. class_copyIvarList 与 class_copyPropertyList 的区别</h4><ul>
<li>1.class_copyIvarList:能够获取.h 和.m 中的所有属性以及大括号中声明的变量，获取的属性名称有下划线(大括号中的除外)。</li>
<li>2.class_copyPropertyList:只能获取由 property 声明的属性，包括.m 中的，获取的属性名称不带下划线。</li>
</ul>
<h4 id="引申-2-class-ro-t-和-class-rw-t-的区别"><a href="#引申-2-class-ro-t-和-class-rw-t-的区别" class="headerlink" title="引申 2. class_ro_t 和 class_rw_t 的区别"></a>引申 2. class_ro_t 和 class_rw_t 的区别</h4><ul>
<li>class_rw_t 提供了运行时对类拓展的能力，</li>
<li>class_ro_t 存储的大多是类在编译时就已经确定的信息。</li>
<li>二者都存有类的方法、属性（成员变量）、协议等信息，不过存储它们的列表实现方式不同。简单的说 class_rw_t 存储列表使用的二维数组，class_ro_t 使用的一维数组。</li>
<li>class_ro_t 存储于 class_rw_t 结构体中，是不可改变的。保存着类的在编译时就已经确定的信息。</li>
<li>运行时修改类的方法，属性，协议等都存储于 class_rw_t 中</li>
</ul>
<h3 id="31-NSNotification"><a href="#31-NSNotification" class="headerlink" title="31. NSNotification"></a>31. NSNotification</h3><ul>
<li>NSNotificationCent 子线程中发出通知，也要在主线程中刷新 UI</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 比如</span><br><span class="line">   dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       // 刷新UI</span><br><span class="line">   &#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>NSNotificationCenter 用完之后不移除， 会崩溃么？</li>
<li>有时候会导致 crash。比如在通知事件中处理数据或者 UI 事件，但是由于通知的不确定性造成事件的不确定，有异步操作在通知事件中处理等都可能造成崩溃。</li>
<li>而且通知的崩溃很难检测。</li>
</ul>
<h3 id="32-什么情况使用-weak-关键字，相比-assign-有什么不同？（轮回系列）"><a href="#32-什么情况使用-weak-关键字，相比-assign-有什么不同？（轮回系列）" class="headerlink" title="32.  什么情况使用 weak 关键字，相比 assign 有什么不同？（轮回系列）"></a>32.  什么情况使用 weak 关键字，相比 assign 有什么不同？（轮回系列）</h3><ul>
<li>weak 这个词儿解决了一件事情，就是内存的事情</li>
<li>在 ARC 中 weak 的出现解决了一些循环引用的问题， 比如 delegate， xib 连线出来的控件一般也是 weak（也可以用 strong ）</li>
<li>weak 表明了一种“非拥有的关系”，不保留新值，也不释放旧值。</li>
<li>assign 也是如此，但常用的 assign 一般用于基本数据类型（CGFloat 或 NSlnteger 等）</li>
<li>assign 可以用于非 OC 对象，也可以用于 OC 对象（MRC 时代使用）， 但是 weak 必须用在 OC 对象。</li>
</ul>
<h4 id="引申-1-关键字-copy-的用法"><a href="#引申-1-关键字-copy-的用法" class="headerlink" title="引申 1.关键字 copy 的用法"></a>引申 1.关键字 copy 的用法</h4><ul>
<li>block 用 Copy 是 MRC 时代留下来的传统。在 MRC 中方法内部的 block 是在栈区的， 使用 copy 可以把它放到堆区。  在 ARC 中写不写都行，用 Strong 也是可以的。</li>
<li>NSString、NSArray、NSDictionary 也经常使用 copy， 因为里面有对应的可变的子类型，为了确保安全性， <strong>建议使用 copy 修饰</strong></li>
</ul>
<h4 id="引申-2-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#引申-2-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="引申 2.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的"></a>引申 2.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h4><ul>
<li>@property = ivar（实例变量） + getter + setter</li>
<li>自动合成</li>
</ul>
<h3 id="33-说说内存管理"><a href="#33-说说内存管理" class="headerlink" title="33. 说说内存管理"></a>33. 说说内存管理</h3><ul>
<li>其实遇到这道题，挺纠结的，有些 TMD 面试官就是习惯搞人，从这个玩意里面  能往死给你嗑！ 你要看过相关内存管理的详细原理，你会发现这里面的 C++操作很多，没学过 C++的人能看个八九不离十，可是也只是能说个大其概，但是内部细节还是得用 C++来说，废话不多说， 直接上说所谓得面试答案。</li>
<li><strong>粗糙版本这么回答</strong>，</li>
<li><strong>版本一</strong>： 内存中每一个对象都有一个属于自己的引用计数器。当某个对象 A 被另一个对象引用时，A 的引用计数器就+1,如果再有一个对象引用到 A，那么 A 的引用计数器就再+1。当其中某个对象不再引用 A 了，A 的引用计数器会-1。直到 A 的引用计数减到了 0,那么就没有人再需要它了，就是时候把它释放掉了</li>
<li><strong>版本二</strong>：对象通过 alloc copy new 生成得得对象在 MRC 年代需要手动管理内存， 利用得技术是 returnCount<strong>引用计数器</strong>，来管理对象得释放时机，alloc 创建对象引用计数器 + 1， retain 持有关系 引用计数器 +1，release 引用计数器 - 1。 如果当前对象得 returnCount = 0 对象就会被在 dealloc 方法里面适当时机进行释放（啥时候释放？）如果当前 returnCount 大于 0 得时候，就会一直被持有。</li>
<li><strong>稍微详细版本的</strong>，首先当 alloc copy new 生成得对象里面  在内部底层源码也同时和当前对象相关联得 SideTable， 其内部有三个属性， 一个是一把自旋锁，一个是引用计数器相关，一个是维护 weak 生命得属性得表， 其中 retain、release 对利用键值对会对当前对象得引用计数器进行加减操作（位移），如果当前引用计数器为 0 得时候，其 dealloc 内部会删除当前的引用计数器，并且释放当前对象。</li>
<li><strong>详情请查看</strong><a href="https://www.jianshu.com/p/ef6d9bf8fe59" target="_blank" rel="noopener">www.jianshu.com/p/ef6d9bf8f……</a></li>
</ul>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul>
<li>1、imageName 与 imageWithContentsOfFile 区别？</li>
<li>imageWithContentsOfFile： 加载本地目录图片，并不会缓存，占用内存小， 不能加载 image.xcassets 里面的图片资源。 相同的图片会被<strong>重复加载到内存中</strong></li>
<li>imageName：加载到内存中， 会缓存起来， 占用内存较大，相同的图片不会被重复加载到内存当中，会读取 image.xcassets 的图片图片资源。</li>
<li><strong>如果不断重复</strong>读取同一个图片，则使用 imageName</li>
<li><strong>如果不需要重复</strong>读取同一个图片，并且需要低内存，则使用 imageWithContentsOfFile</li>
<li>2.IBOutlet 连出来的视图属性为什么可以被设置成 weak?</li>
<li>因为链接之 Xcode 内部把链接的控件 放进了一个_topLevelObjectsToKeepAliveFromStoryboard 的私有数组中，这个数组强引用这所有 top level 的对象 所以用 weak 也无伤大雅。</li>
<li><ol>
<li>id 为什么不能用点语法？</li>
</ol>
</li>
<li>点语法就是 setter 和 getter 方法， 然而 id 类 无法确定所指的类是什么类型， 寻不到 setter 个 getter 方法，id 类型的对象  只能用【】方法调用方法</li>
<li>4.id 和 NSObject 的区别?<ul>
<li>id 是 struct objc_object 结构体指针，可以指向任何 OC 对象，当然不包括 NSInteger 等类型，因为这些数据类型不是 OC 对象。</li>
</ul>
</li>
<li>另外 OC 的基类不止有 NSObject 一个，还有个 NSProxy 虚类。所以说 id 类型和 NSObject 并不是等价的。</li>
<li>5 . OC 中 Null 与 nil 的区别<ul>
<li>NULL 是指指针是空值，用来判断 C 指针；</li>
<li>nil 是指一个 OC 对象（指针)为空；</li>
<li>Nil 是指一个 OC 类为空；</li>
<li>NSNull 则用于填充集合元素；这个类只有一个方法 null，并且是单例的；</li>
</ul>
</li>
<li>6 . 自旋锁和互斥锁</li>
<li>相同点：都能保证同一时间只有一个线程访问共享资源，都能保证系统安全</li>
<li>不同点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">互斥锁：如果共享数据已经有了其他线程加锁了，线程会进行休眠状态等待锁，一旦被访问的资源被解锁，则等待资源的线程会被唤醒。信号量dispatch_semaphore 为互斥锁   @synchronized是NSLock的封装 属于互斥锁  互斥锁一般用于等待时间较长的情况</span><br><span class="line">**适用于**：线程等待锁的时间较长</span><br><span class="line"></span><br><span class="line">自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行。OSSpinLock 属于自旋锁   自旋锁一般用于时间较短的情况，OSSpinLock</span><br><span class="line">**适用于**：线程等待锁的时间较端</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>7 . 进程和线程的区别</li>
<li>进程是指在系统中正在运行的一个应用程序</li>
<li>线程是进程中的一个实体，一个进程想要执行任务， 必须至少有一条线程，应程序启动的时候会默认开启一条线程，也就是主线程</li>
<li>一个进程拥有多个线程</li>
<li>8 LayoutSubviews 和 drawRect 调用时机 <strong>LayoutSubviews 调用时机</strong><ul>
<li>init 初始化不会调用 LayoutSubviews 方法</li>
<li>addsubView 时候会调用</li>
<li>改变一个 View 的 frame 的时候调用</li>
<li>滚动 UIScrollView 导致 UIView 重新布局的时候会调用</li>
<li>手动调用 setNeedsLayout 或者 layoutIfNeeded</li>
</ul>
</li>
</ul>
<p><strong>drawRect 调用时机</strong></p>
<ul>
<li>drawRect 掉用是在 Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些 View 的 drawRect 就开始画了.、</li>
<li>9 cocoaPods 里面 pod install 和 update 的区别？ <strong>pod install</strong></li>
</ul>
<blockquote>
<ul>
<li>一般是第一次想要为项目添加 pod 的时候使用的，当然也可以在添加和移除库使用</li>
<li>每次 pod install 的时候，pod install 回为每一个安装的 pod 库在 Podfile.lock 文件中写入其版本号，并且锁定当前版本号。</li>
<li>如果 pod install 的时候，不会更新其版本库，而是去下载新的或者移除当前版本 <strong>pod update</strong></li>
<li>当执行了 pod update 的时候，cocoaPods 不会考虑 Podfile.lock 中的版本。直接去更新当前所有的库到最新,然后 Podfile.lock 会更新这一次的版本号。</li>
</ul>
</blockquote>
<ul>
<li>10 frame 和 masonry 哪个性能好？为什么</li>
</ul>
<blockquote>
<ul>
<li>有的相对布局最终都会转换成 Frame 绝对布局  中间多了一层转换的操作</li>
</ul>
</blockquote>
<hr>
<ul>
<li>11 . iOS 从 iOS9 - 13 的特性</li>
</ul>
<p><strong>iOS9</strong></p>
<blockquote>
<p>从 HTTP 升级到 HTTPS App 瘦身 下面有讲 这里不赘述（ App 瘦身 ） 新增 UIStackView</p>
</blockquote>
<p><strong>iOS10</strong></p>
<blockquote>
<p>新增通知推送相关的操作。自定义通知弹窗，自定义通知类型（地理位置，时间间隔，日历等）</p>
</blockquote>
<p><strong>iOS11</strong></p>
<blockquote>
<p>无线 调试 齐刘海儿，导航条，安全距离等</p>
</blockquote>
<p><strong>iOS12</strong></p>
<blockquote>
<p>启动速度优化 应用启动速度提升 40% 键盘响应速度提升 50% 相机启动速度提升 70%</p>
</blockquote>
<p><strong>iOS13</strong></p>
<blockquote>
<p>黑暗模式  详情请查阅 <a href="https://www.jianshu.com/p/0da3b107f06c" target="_blank" rel="noopener">www.jianshu.com/p/0da3b107f……</a></p>
</blockquote>
<hr>
<h2 id="二、App-包以及启动过程"><a href="#二、App-包以及启动过程" class="headerlink" title="二、App 包以及启动过程"></a>二、App 包以及启动过程</h2><h4 id="App-瘦身"><a href="#App-瘦身" class="headerlink" title="App 瘦身"></a>App 瘦身</h4><p><strong>1、App 如何瘦身？</strong></p>
<ul>
<li>删除陈旧代码、删除陈旧 xib/sb，删除无用的图片资源（检测未使用图片的工具<strong>LSUnusedResources</strong> ）</li>
<li>无损压缩图片，本地音视频压缩。以直接减少图片大小</li>
<li>使用 webP 格式的图片（加载速度比较慢，但可以达到瘦身的效果）</li>
<li>减小类名称的长度（高性能的话可以试一试）</li>
<li>减少使用静态库</li>
<li>一些主题类的东西提供下载功能，不直接打包在应用包里面，按需加载资源</li>
<li>iOS9 之后的新特性 <strong>应用程序切片(App Slicing)、中间代码(Bitcode)和按需加载资源(On Demand Resources)</strong></li>
</ul>
<blockquote>
<p><strong>Slicing</strong>： 这个过程是 iOS9 出来之后 不需要程序员干预的一个瘦身的过程，简单来说就是我们再上传 IPA 包到 iTunes Connect，然后 AppStore 会对 app 进行切片，切成特定的机型想要的数据，比如@3x 给 max 用，@2x 就自动剔除了。 <strong>是一个自动的过程</strong>、 <strong>Bitcode</strong>：是一种中间码，如果配置了 Bitcode（Xcode7 以后默认开启）的程序会在 App Store Connect 上被重新编译等一系列操作，进而苹果内部会对可执行文件进行优化，也就是说不需要我们干预什么东西，也操作不了， 如果后面苹果有更牛逼的优化操作，也是苹果的事情， 跟我们个人开发者一毛钱关系没有。 <strong>On Demand Resources</strong>   按需加载， 是程序员自己手动操作，说白了就是在用的时候去下载某些资源， 但是我们自己在配置的时候都需要配置，要额外写一些代码啥的，等我们提交到市场的时候， 苹果内部会把我们按需加载的资源从包里面做了一些抽离操作啥的， 让我们的包在下载的时候更小，举个例子，就是吃鸡里面沙漠地图如果玩家不自己下载， 就玩不了沙漠。</p>
</blockquote>
<blockquote>
<p><strong>on-demond resource(ODR)</strong>具体请查看原理版本：<a href="https://www.jianshu.com/p/bacedd8a3ad8" target="_blank" rel="noopener">www.jianshu.com/p/bacedd8a3……</a><br> 或者详细使用版本：<a href="http://www.cocoachina.com/articles/12155" target="_blank" rel="noopener">www.cocoachina.com/articles/12……</a></p>
</blockquote>
<p>关于 <strong>slicing, bitcode, on-demond resource(ODR)</strong>的参考资源<a href="https://blog.csdn.net/zhuod/article/details/70051514?utm_source=blogxgwz6" target="_blank" rel="noopener">https://blog.csdn.net/zhuod/article/details/70051514?utm_source=blogxgwz6</a></p>
<hr>
<p><strong>2、app 启动时候都经历了什么？</strong></p>
<p><strong>启动</strong>分为<strong>两种</strong>。 一种是之前启动过，按了一下 home 键，然后再点启动，这个启动叫<strong>热启动</strong>，另外就是第一次启动 app，或者启动杀死之后的 app 叫做<strong>冷启动</strong></p>
<blockquote>
<p>根据 info.plist 里面的设置加载，建立沙箱，权限检查等 加载可执行文件 加载动态库 objc 运行时的初始化处理（类的注册，category 注册，selector 唯一性检查等等） 初始化，包括+load 方法 执行<strong>main</strong>函数 Application 初始化，到 applicationDidFinishLaunchingWithOptions 执行完 渲染屏幕，到 viewDidAppear 执行完毕，展现给用户</p>
</blockquote>
<ul>
<li>mian 之前</li>
</ul>
<blockquote>
<p>根据 info.plist 里面的设置加载，建立沙箱，权限检查等 加载可执行文件 加载动态库 objc 运行时的初始化处理（类的注册，category 注册，selector 唯一性检查等等） 初始化，包括+load 方法</p>
</blockquote>
<ul>
<li><p>mian 之后</p>
<ul>
<li>如图</li>
<li>加载流程如下：</li>
</ul>
<p>图丢了！！！！！百度去吧！</p>
</li>
</ul>
<hr>
<p><strong>3、优化启动时间</strong></p>
<ul>
<li>启动时间是用户点击 App 图标，到第一个界面展示的时间。</li>
</ul>
<blockquote>
<p>注意：启动时间在小于 400ms 是最佳的，因为从点击图标到显示 Launch Screen，到 Launch Screen 消失这段时间是 400ms。启动时间不可以大于 20s，否则会被系统杀掉。</p>
</blockquote>
<ul>
<li>以 main 函数作为分水岭，启动时间其实包括了两部分：<ul>
<li><strong>main 函数之前（分析并加载动态库，注册需要的类（包括系统的类），Category 中的方法也会注册到对用的类中，执行必要的初始化方法（ +load 方法）等等</strong></li>
<li><strong>main 函数到第一个界面的 viewDidAppear:</strong>。</li>
</ul>
</li>
<li>所以，优化也是从两个方面进行的，个人建议优先优化后者，因为绝大多数 App 的瓶颈在自己的代码里。</li>
</ul>
<p><strong>mian 函数之前的启动优化</strong></p>
<ul>
<li><strong>减少动态库的数量</strong>（这是目前为止最耗时的了， 基本上占了 95%以上的时间）</li>
<li><strong>合并动态库</strong>，比如自己写的 UI 控件合并成自己的 UIKit</li>
<li><strong>确认动态库是 optional 还是 required</strong>。如果该 Framework 在当前 App 支持的所有 iOS 系统版本都存在，那么就设为 required，否则就设为 optional，因为 optional 会有些额外的检查</li>
<li><strong>合并 Category</strong>（UIView+Frame,UIView+AutoLayout 合并成一个）</li>
<li>将不必需在+load 方法中做的事情，延时放到+initialize。</li>
</ul>
<hr>
<p><strong>mian 函数之后的启动优化</strong> 首先分析一下从 main 函数开始执行，到第一个页面显示， 这段时间做了哪些事情</p>
<blockquote>
<ol>
<li>执行 didFinishLaunchingWithOptions 方法</li>
<li>初始化 Window，初始化基础 ViewContreoller（一般是 UINavigationController+UITabViewController）</li>
<li>获取数据（本地和远程）</li>
<li>最后展示给用户</li>
<li><strong>减少创建线程</strong>（高性能 iOS 开发一书中提到，线程不仅仅有创建时的时间开销，还会消耗内核的内存，即应用的内存空间。 <strong>每个线程大约消耗 1KB 的内核内存空间</strong>。<strong>线程创建的耗时</strong>（不包含启动时间），其区间范围在 4000~5000 微秒，<strong>即 4~5 毫秒</strong>。创建线程后<strong>启动线程的耗时</strong>区间为 <strong>5~100</strong> 毫秒，<strong>平均大约在 29 毫秒</strong>。这是很大的时间开销，<strong>若在应用启动时开启多个线程，则尤为明显</strong>。线程的启动时间之所以如此之长，是因为多次的上下文切换所带来的开销。所以线程在开发过程中也避免滥用）</li>
<li><strong>合并或者删减不必要的类(或者分类)和函数</strong>objc 的类越多，函数越多启动越慢</li>
<li><strong>在设计师可接受的范文尽量使用小的图片</strong></li>
</ol>
</blockquote>
<ul>
<li><strong>AppDelegate</strong> 通常优化的一般来说，还是从 AppDelegate 先入手优化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">didFinishLaunchingWithOptions</span><br><span class="line">applicationDidBecomeActive</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>优化的核心思想就是，能延时的延时， 不能延时的尽量放到后台去优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 日志、统计等必须在 APP 一启动就最先配置的事件。仍然把它留在 didFinishLaunchingWithOptions 里启动。</span><br><span class="line">- 项目配置、环境配置、用户信息的初始化 、推送、IM等事件，这些功能在用户进入 APP 主体的之前是必须要加载完的，把他放到广告页面的viewDidAppear启动。</span><br><span class="line">- 其他 SDK 和配置事件，由于启动时间不是必须的，所以我们可以放在第一个界面的 viewDidAppear 方法里，这里完全不会影响到启动时间。</span><br><span class="line">- 每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log</span><br><span class="line">- 尽量不要在didFinishLaunchingWithOptions 里面创建和开启多线程</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>参考文献<a href="https://www.jianshu.com/p/f40fdd8799b8" target="_blank" rel="noopener">https://www.jianshu.com/p/f40fdd8799b8</a> 其文章内部作者谈到了美团关于启动优化的相关分析，看似似曾相似，没记错的画《高性能 iOS 应用开发》这本书就是美团这几个哥们儿翻译的吧，实现方式和书中颇为相似。</p>
<hr>
<p><strong>3、App 电量消耗</strong></p>
<ul>
<li>1.定位</li>
<li>2.网络请求</li>
<li>3.CPU 处理</li>
<li>4.GPU 处理</li>
<li>5.Bluetooth</li>
</ul>
<p>定位优化</p>
<blockquote>
<p>1.尽量不要实时更新 2.定位精度尽量不要太高</p>
</blockquote>
<p>网络优化</p>
<blockquote>
<p>1.减少、压缩网络数据 2.能使用缓存就使用缓存，减少网络请求 3.断点续传 4.批量传输 5.设置适合的超时时间，用户可以取消耗时的网络请求 6.网络不可用时就不要再执行网络请求了</p>
</blockquote>
<p>CPU/GPU 优化</p>
<blockquote>
<p>相关离屏渲染操作尽量避免 内存管理处理好 使用懒加载 使用绘制 图片与 imageView 相同大小避免多余运算 Timer 的时间间隔不宜太短,满足需求即可 线程适量,不宜过多,不要阻塞主线程 适当使用多线程 减少视图刷新：确保必要的时候才刷新，能刷新 1 行 cell 最好只刷新一行；</p>
</blockquote>
<p>为了优化耗电我们还可以做： 1.尽量不要使用定时器 2.优化 I/O 操作（文件的读写操作） 2.1 最好不要频繁读写小数据，最好批量读写 2.2 数据量比较大的时候可以考虑使用数据库 2.3 读写大量重要数据时，考虑用 dispatch_io，其提供了基于 GCD 的异步操作文件 I/O 的 API。用 dispatch_io 系统会优化磁盘访问</p>
<p><strong>高性能 iOS 应用开发中提到一下几点</strong></p>
<ul>
<li>1、CPU 优化</li>
</ul>
<blockquote>
<ul>
<li>数据处理（例如文本格式优化）</li>
<li>待处理的数据大小—-更大的显示屏允许软件在单个视图中展示更多的信息,但这也意味着要处理更多的数据</li>
<li>处理数据的算法和数据结构</li>
<li>执行更新的次数，尤其是在数据更新之后，触发应用的状态或者 UI 进行更新（比如刷新单行 cell）</li>
<li>服务器中的数据尽量不要在客户端上处理（例如服务器字符串，在客户端进行拆分操作）</li>
<li>按需加载（例如 tableViewcell 不需要一下子全部渲染，快速滑动的时候  过程中的留白处理。）</li>
</ul>
</blockquote>
<ul>
<li>2、网络</li>
</ul>
<blockquote>
<ul>
<li>在进行网络请求之前，先检查是否有网络连接。（没网络的时候，不要请求网络）</li>
<li>避免没有连接 WiFi 的情况下进行高带宽的消耗操作（因为 3G、4G 等手机网络耗电量远大于 WIFi 信号），例如视频流在 4G 或者非 Wifi 情况下应该给出响应的提示。</li>
</ul>
</blockquote>
<ul>
<li>3、定位</li>
</ul>
<blockquote>
<ul>
<li>尽量不要实时更新</li>
<li>定位精度尽量不要太高</li>
</ul>
</blockquote>
<hr>
<p>##三、算法</p>
<h4 id="定义相关"><a href="#定义相关" class="headerlink" title="定义相关"></a>定义相关</h4><ol>
<li>链表和数组的区别是什么？ 链表和字典的区别是什么？</li>
</ol>
<blockquote>
<p>数组在内存中是逐个存放的，链表每隔节点没有相对固定的位置关系 数组被声明后，大小就固定了，不能进行动态扩充。 链表可以动态生成节点，并且添加到已有的链表后面 数组存在越界问题，链表则不存在 数组的插入删除的时间复杂度是 O(n)，链表 O(1) 数组的<strong>查询下标</strong>时间复杂度为 O(1)， 链表为 O(n) 根据值查询的时间复杂度，链表和数组都是 O(n)</p>
</blockquote>
<ol>
<li>如何检测链表中是否有环？</li>
</ol>
<blockquote>
<p>思路 假设有两个学生 A 和 B 在跑道上跑步，两人从相同起点出发，假设 A 的速度为 2m/s，B 的速度为 1m/s,结果会发生什么？ 答案很简单，A 绕了跑道一圈之后会追上 B！ 将这个问题延伸到链表中，跑道就是链表，我们可以设置两个指针，a 跑的快，b 跑的慢，如果链表有环，那么当程序执行到某一状态时，a==b。如果链表没有环，程序会执行到 a==NULL，结束。</p>
</blockquote>
<p>###1、 调换 A 和 B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//    int a = 10;</span><br><span class="line">//    int b = 20;</span><br><span class="line">//</span><br><span class="line">//    a = a + b;</span><br><span class="line">//    b = a - b;</span><br><span class="line">//    a = a - b;</span><br><span class="line">//</span><br><span class="line">//    NSLog(@&quot;a = %d , b = %d&quot;, a, b);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//    a = a*b;</span><br><span class="line">//    b = a/b;</span><br><span class="line">//    a = a/b;</span><br><span class="line">//</span><br><span class="line">//    NSLog(@&quot;1 =====    : a = %d , b = %d&quot;, a, b);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>###2、最大公约数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//    int n = 20,v = 30,temp = 0,max,min;</span><br><span class="line">//</span><br><span class="line">//    if (n&gt;v) &#123;</span><br><span class="line">//        max = n;</span><br><span class="line">//        min = v;</span><br><span class="line">//    &#125; else &#123;</span><br><span class="line">//        max = v;</span><br><span class="line">//        min = n;</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//    while (min != 0) &#123;</span><br><span class="line">//        temp = max - min;</span><br><span class="line">//        max = min;</span><br><span class="line">//        min = temp;</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    NSLog(@&quot;%d&quot;, max);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>###3、打印 2 - 100 的素数（质数） 除了 1 和自身被整除的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//    NSMutableArray *primeNumberArray =[NSMutableArray array];</span><br><span class="line">//    for(int i=2; i&lt;=100; i++) &#123;</span><br><span class="line">//</span><br><span class="line">//        NSInteger n = 0;</span><br><span class="line">//</span><br><span class="line">//        for(int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">//</span><br><span class="line">//            if(i % j == 0) &#123;</span><br><span class="line">//                n = n + 1;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;</span><br><span class="line">//</span><br><span class="line">//        if(n == 2) &#123;</span><br><span class="line">//            [primeNumberArray addObject:@(i)];</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    NSLog(@&quot;primeNumber = %@&quot;,primeNumberArray);</span><br><span class="line">//</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>###4、 字符串倒叙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//    NSString *string = @&quot;hei Son 我是你father&quot;;</span><br><span class="line">//    NSMutableString *string1 = [NSMutableString string];</span><br><span class="line">//    for (NSInteger i = string.length; i&gt;0; i--) &#123;</span><br><span class="line">//        [string1 appendString:[string substringWithRange:NSMakeRange(i -1,1)]];</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    NSLog(@&quot;%@&quot;, string1);</span><br><span class="line">//</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>###5、 寻找出字符串中有那些中文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//    for (int i = 0; i &lt; string.length; i++) &#123;</span><br><span class="line">//        NSString *str1 = [string substringWithRange:NSMakeRange(i, 1)];</span><br><span class="line">//        const char *cStr = [str1 UTF8String];</span><br><span class="line">//        if (strlen(cStr) == 3 ) &#123;  // oc中 中文三个字节</span><br><span class="line">//            NSLog(@&quot;%@&quot;, str1);</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>####6. 排序</p>
<ul>
<li>冒泡排序</li>
</ul>
<blockquote>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i&lt;result.count-1; i++) &#123;</span><br><span class="line">        for (int j = 0; j&lt;result.count-1-i; j++) &#123;</span><br><span class="line">            NSInteger left = [result[j] integerValue];</span><br><span class="line">            NSInteger right = [result[j+1] integerValue];</span><br><span class="line">            if (left&gt;right) &#123;</span><br><span class="line">                [result exchangeObjectAtIndex:j withObjectAtIndex:j+1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">NSLog(@&quot;%@&quot;,result);</span><br><span class="line">时间复杂度O(n^2)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>选择排序</li>
</ul>
<blockquote>
<p>选择排序就是通过遍历数组找出每次遍历数组的最小元素的下标，然后将其按顺序从第一位依次排列</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     //self.array = @[@2,@4,@3,@1];</span><br><span class="line">     NSMutableArray *mutableArray = [self.array mutableCopy];//oc数组中不能存储基本数据类型，所以快速赋值完成后，系统默认数组元素为NSNumber类型</span><br><span class="line">    if (mutableArray == nil || [mutableArray count] == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; [mutableArray count]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSInteger minIdx = i;//默认最小值的索引为i</span><br><span class="line">        for (int j = i+1; j &lt; [mutableArray count]; j++)//通过循环寻找当前数组中最小值的索引值</span><br><span class="line">        &#123;</span><br><span class="line">            if (NSOrderedAscending == [mutableArray[j] compare:mutableArray[minIdx]])//NSNumber类判断大小方法，这句话的意思是当mutableArray[j] &lt;mutableArray[minIdx]时</span><br><span class="line">            &#123;</span><br><span class="line">                minIdx = j;//更新数组中最小值的索引值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [mutableArray exchangeObjectAtIndex:i withObjectAtIndex:minIdx];//将每次循环结束后找到的最小值交换到数组的第i位</span><br><span class="line">        NSLog(@&quot;%@&quot;,mutableArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度为O(n)。最坏情况下仍为O(n^2)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>升序/降序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *priceArray = [NSMutableArray arrayWithObjects:@&quot;0.2&quot;,@&quot;5&quot;,@&quot;44&quot;,@&quot;67&quot;,@&quot;98.5&quot;,@&quot;1.55&quot;, nil];</span><br><span class="line"> </span><br><span class="line">[priceArray sortUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2)  &#123;</span><br><span class="line">     if ([obj1 integerValue] &lt; [obj2 integerValue])&#123;</span><br><span class="line">         return NSOrderedAscending;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       return NSOrderedDescending;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br><span class="line"> </span><br><span class="line">这里再次得到的priceArray即为升序排列的数组；</span><br><span class="line">若果想要得到降序的调换一下return的位置即可</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>####7 寻找最近的公共 View</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 所有View的父View</span><br><span class="line">+ (NSArray *)superViews:(UIView *)view&#123;</span><br><span class="line">    if (view==nil) &#123;</span><br><span class="line">        return @[];</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableArray *result = [NSMutableArray array];</span><br><span class="line">    while (view!=nil) &#123;</span><br><span class="line">        [result addObject:view];</span><br><span class="line">        view = view.superview;</span><br><span class="line">    &#125;</span><br><span class="line">    return [result copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 相互对比两个节点中的view，出现一样就返回</span><br><span class="line">+ (UIView *)commonView_1:(UIView *)viewA  andView:(UIView *)viewB&#123;</span><br><span class="line">    NSArray *arr1 = [self superViews:viewA];</span><br><span class="line">    NSArray *arr2 = [self superViews:viewB];</span><br><span class="line">    for (NSUInteger i =0; i&lt;arr1.count; ++i) &#123;</span><br><span class="line">        UIView *targetView = arr1[i];</span><br><span class="line">        for (NSUInteger j=0; j&lt;arr2.count; ++j) &#123;</span><br><span class="line">            if (targetView == arr2[j]) &#123;</span><br><span class="line">                return targetView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 利用NSSet中的hash表，可以将上面代码进行进一步优化</span><br><span class="line">+ (UIView *)commomView_2:(UIView *)viewA andView:(UIView *)viewB&#123;</span><br><span class="line">    NSArray *arr1 = [self superViews:viewA];</span><br><span class="line">    NSArray *arr2 = [self superViews:viewB];</span><br><span class="line">    NSSet *set = [NSSet setWithArray:arr2];</span><br><span class="line">    for (NSUInteger i =0; i&lt;arr1.count; ++i) &#123;</span><br><span class="line">        UIView *targetView = arr1[i];</span><br><span class="line">        if ([set containsObject:targetView]) &#123;</span><br><span class="line">            return targetView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   return nil;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>####8.数组题：如何在有序数组中找出和等于给定值的两个元素？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr = @[@&quot;1&quot;, @&quot;12&quot;, @&quot;13&quot;, @&quot;23&quot;, @&quot;31&quot;, @&quot;43&quot;, @&quot;52&quot;, @&quot;66&quot;, @&quot;88&quot;, @&quot;111&quot;, @&quot;127&quot;, @&quot;199&quot;];</span><br><span class="line">[self confirmNumbers:arr total:199];</span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)confirmNumbers:(NSArray *)array total:(NSInteger)totalNmuber  &#123;</span><br><span class="line">    if (array.count &lt;= 1) &#123; return; &#125;</span><br><span class="line"></span><br><span class="line">    NSInteger tempAddCount = 0;</span><br><span class="line">    NSInteger tempDeleltCount = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt;= array.count; i++) &#123;</span><br><span class="line">        NSInteger tNamber = [array[tempAddCount] integerValue] + [array[array.count-1-tempDeleltCount] integerValue];</span><br><span class="line">        if (tNamber == totalNmuber) &#123;</span><br><span class="line">            NSLog(@&quot;%ld, %ld,  第一个元素%@ - 后面的元素%@&quot;, (long)tempAddCount, (long)tempDeleltCount, array[tempAddCount] ,array[array.count-tempDeleltCount-1]);</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (tNamber &lt; totalNmuber) &#123;</span><br><span class="line">            tempAddCount ++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tempDeleltCount ++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i == array.count - 1) &#123;</span><br><span class="line">            NSLog(@&quot;啥都没匹配着&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="9-用递归写一个算法，计算从-1-到-100-的和"><a href="#9-用递归写一个算法，计算从-1-到-100-的和" class="headerlink" title="9 用递归写一个算法，计算从 1 到 100 的和"></a>9 用递归写一个算法，计算从 1 到 100 的和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%ld&quot;, [self getSumResult:100]);</span><br><span class="line"></span><br><span class="line">- (NSInteger)getSumResult:(NSInteger)number &#123;</span><br><span class="line">    if (number &lt;=0 ) &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return number + [self getSumResult:number - 1];</span><br><span class="line">&#125;</span><br><span class="line">// 递归效率差的原因是 每一次调用函数（自己）都是要有内存开销的,影响CUP的效率</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="10-打乱一个数组"><a href="#10-打乱一个数组" class="headerlink" title="10.打乱一个数组"></a>10.打乱一个数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  NSArray* arr = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;];</span><br><span class="line">    arr = [arr sortedArrayUsingComparator:^NSComparisonResult(NSString *str1, NSString *str2) &#123;</span><br><span class="line">        int seed = arc4random_uniform(2);</span><br><span class="line">        if (seed) &#123;</span><br><span class="line">            return [str1 compare:str2];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return [str2 compare:str1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<hr>
<p>##三、软技术篇 ###1.开发过程中， 你碰到那些技术难点？是怎么解决的？</p>
<ul>
<li>其实这个题主要还是面试官看想了解你的真实项目经验， 如果你回答的东西，根本就算不上是什么技术问题，而是基础问题那估计也没什么聊下去的必要了， 举个例子，你回答的是“<strong>我在开发过程中总是发现 UITableView 这个控件写起来比较麻烦， 而且还总是报数组越界的问题</strong>” 那么对不起，  你最多能找一个实习的工作。因为你能说出这个问题，我估计你上面的硬核面试题，一半儿都不知道咋回事！</li>
<li>其实这题也没那么高大上，说一下你真实开发过程中遇到的难点，说的越高大上越好， 最好是把面试官说懵逼了，当然如果你有自信的话，最好别夸大，万一你遇上一个恰好在这个领域人家更牛逼呢？</li>
<li>举个例子“<strong>我在开发我们项目的时候， 涉及到图像处理的问题，就比如说现在网络上比较火的用 SDWebImage 下载超清大图的时候出现的崩溃问题，因为 decodeImageWithImage 这个方法用于对图片进行压缩并且缓存起来，以保证 tableview/collectionview 交互更加流畅，但是如果用此方法加载超清大图的时候， 会适得其反，有可能导致上 G 的内存消耗， 解决办法是对于高清图片，应该放在图片解压之后，禁止缓存解压后的数据。 代码如下</strong>”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - SD4.X的解决办法</span><br><span class="line">[[SDImageCache sharedImageCache] setShouldDecompressImages:NO];</span><br><span class="line">[[SDWebImageDownloader sharedDownloader] setShouldDecompressImages:NO];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- SD5.0 及以上的解决办法</span><br><span class="line">SDWebImageAvoidDecodeImage添加了这个枚举，意思是在子线程程解压缩图片</span><br><span class="line">[self.imageView sd_setImageWithURL:self.url placeholderImage:[UIImage imageNamed:@&quot;logo&quot;] options:SDWebImageAvoidDecodeImage];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>更多详情请查看 也必须看！</strong></li>
<li><a href="https://www.jianshu.com/p/b36e96d6d65c" target="_blank" rel="noopener">www.jianshu.com/p/b36e96d6d……</a></li>
<li><a href="https://www.jianshu.com/p/64be3aed23fd" target="_blank" rel="noopener">www.jianshu.com/p/64be3aed2……</a></li>
<li>在举个例子“<strong>由于在开发过程中，用到的所有图片必须是原图， 问题就出现了， 如果几张图片是超清的超大图片，把这些图片全部渲染到一个画布中并且进行随机形状的超高清拼图， 这个过程会出现一个奇怪的问题，就是绘制的结果是大概率会变成 一张纯白色的没有任何图案的图片，出现的原因是因为在 App 内部如果正在运行的内存达到一定的值得时候绘制图像的上下文就会获取一个空白的图片，解决办法因为是概率事件所以内部做了一个循环渲染的机制，在特定次数范围内，如果出现绘制成功的话返回正常的图片，如果没有正确绘制，则做一个内部的提示语 App 内部没有任何反应， 所以如果制作跟图片相关的项目，特别涉及到自定义系统相册的功能，最好优化好内存问题，因为内存优化不好，导致的问题有很多系统层级的 BUG。而且很难找到问题的原因</strong>。</li>
<li><strong>这就把面试官引向了一个优化内存的事情。比如优化内存的工具， 检测内存泄漏，循环引用的工具等等。 下面会一一介绍。</strong></li>
</ul>
<p>###2.过程中， 你用过什么调试工具？</p>
<ul>
<li>instrument</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Leaks（泄漏）：一般的查看内存使用情况，检查泄漏的内存，并提供了所有活动的分配和泄漏模块的类对象分配统计信息以及内存地址历史记录；</span><br><span class="line">- locations（内存分配）：跟踪过程的匿名虚拟内存和堆的对象提供类名和可选保留/释放历史； </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://wrapperss.github.io">Wrappers</a>
            <p>原文链接：<a href="https://wrapperss.github.io/2020/10/05/iOS面试题-2/">https://wrapperss.github.io/2020/10/05/iOS面试题-2/</a>
            <p>发表日期：<a href="https://wrapperss.github.io/2020/10/05/iOS面试题-2/">October 5th 2020, 5:57:50 pm</a>
            <p>更新日期：<a href="https://wrapperss.github.io/2020/10/05/iOS面试题-2/">October 5th 2020, 6:07:06 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/10/05/组件化之URL-Route/" title= "组件化之 URL Route">
                    <div class="prevTitle">组件化之 URL Route</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC80MTM1My8xNzkwMA==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:wrappers@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/Wrapperss" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/wechat.jpeg" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：Category-能否添加成员变量？如果可以，如何给-Category-添加成员变量"><span class="toc-number">1.</span> <span class="toc-text">Q：Category 能否添加成员变量？如果可以，如何给 Category 添加成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：为什么分类中属性不会自动生成-setter、getter-方法的实现，不会生成成员变量，也不能添加成员变量"><span class="toc-number">2.</span> <span class="toc-text">Q：为什么分类中属性不会自动生成 setter、getter 方法的实现，不会生成成员变量，也不能添加成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：为什么将以前的方法列表挪动到新的位置用-memmove-呢"><span class="toc-number">3.</span> <span class="toc-text">Q：为什么将以前的方法列表挪动到新的位置用 memmove 呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：为什么优先调用最后编译的分类的方法"><span class="toc-number">4.</span> <span class="toc-text">Q：为什么优先调用最后编译的分类的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：objc-class-结构体中的-baseMethodList-和-methods-方法列表的区别"><span class="toc-number">5.</span> <span class="toc-text">Q：objc_class 结构体中的 baseMethodList 和 methods 方法列表的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：Category-中有-load-方法吗？-load-方法是什么时候调用的？-load-方法能继承吗"><span class="toc-number">6.</span> <span class="toc-text">Q：Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：Category-中有-load-方法吗？-load-方法是什么时候调用的？-load-方法能继承吗-1"><span class="toc-number">7.</span> <span class="toc-text">Q：Category 中有 +load 方法吗？+load 方法是什么时候调用的？+load 方法能继承吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：手动调用-Student-类的-load-方法，但是-Student-类没有实现该方法，为什么会去调用父类的-load-方法，且是调用父类的分类的-load-方法呢"><span class="toc-number">8.</span> <span class="toc-text">Q：手动调用 Student 类的 +load 方法，但是 Student 类没有实现该方法，为什么会去调用父类的 +load 方法，且是调用父类的分类的 +load 方法呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q1：以下打印的-a-的值为多少"><span class="toc-number">9.</span> <span class="toc-text">Q1：以下打印的 a 的值为多少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q1-扩展：如何输出-a-最终的值"><span class="toc-number">10.</span> <span class="toc-text">Q1 扩展：如何输出 a 最终的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q1-扩展：如何让-a-最终的值为-10"><span class="toc-number">11.</span> <span class="toc-text">Q1 扩展：如何让 a 最终的值为 10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：通过-KVC-修改属性会触发-KVO-吗"><span class="toc-number">12.</span> <span class="toc-text">Q：通过 KVC 修改属性会触发 KVO 吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：通过-KVC-键值编码技术是否会破坏面向对象的编程方法，或者说违背面向对象的编程思想呢"><span class="toc-number">13.</span> <span class="toc-text">Q：通过 KVC 键值编码技术是否会破坏面向对象的编程方法，或者说违背面向对象的编程思想呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：-既然-weak-更安全，那么为什么已经有了-weak-还要保留-unsafe-unretained"><span class="toc-number">14.</span> <span class="toc-text">Q： 既然 **weak 更安全，那么为什么已经有了 **weak 还要保留 __unsafe_unretained</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：-释放NSAutoreleasePool对象，使用-pool-release-与-pool-drain-的区别"><span class="toc-number">15.</span> <span class="toc-text">Q： 释放NSAutoreleasePool对象，使用[pool release]与[pool drain]的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：-为什么-block-会产生循环引用"><span class="toc-number">16.</span> <span class="toc-text">Q： 为什么 block 会产生循环引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：-synthesize现在有什么作用呢"><span class="toc-number">17.</span> <span class="toc-text">Q： @synthesize现在有什么作用呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：block-是如何在-ARC-中工作的"><span class="toc-number">18.</span> <span class="toc-text">Q：block 是如何在 ARC 中工作的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q：-哪些类不支持-weak-弱引用"><span class="toc-number">19.</span> <span class="toc-text">Q： 哪些类不支持 weak 弱引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-对象方法和类方法的区别"><span class="toc-number"></span> <span class="toc-text">1.对象方法和类方法的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引伸-1-如果在类方法中调用-self-会有什么问题"><span class="toc-number">1.</span> <span class="toc-text">引伸 1.  如果在类方法中调用 self 会有什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-2-讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的"><span class="toc-number">2.</span> <span class="toc-text">引申 2. 讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-3-为什么对象方法中没有保存对象结构体里面，而是保存在类对象的结构体里面"><span class="toc-number">3.</span> <span class="toc-text">引申 3.  为什么对象方法中没有保存对象结构体里面，而是保存在类对象的结构体里面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-4-类方法存在哪里？-为什么要有元类的存在"><span class="toc-number">4.</span> <span class="toc-text">引申 4. 类方法存在哪里？ 为什么要有元类的存在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-5-什么是野指针"><span class="toc-number">5.</span> <span class="toc-text">引申 5. 什么是野指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-6-如何检测野指针"><span class="toc-number">6.</span> <span class="toc-text">引申 6. 如何检测野指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-7-导致-Crash-的原因有哪些"><span class="toc-number">7.</span> <span class="toc-text">引申 7. 导致 Crash 的原因有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-8-不使用第三方，如何知道已经上线的-App-崩溃问题，-具体到哪一个类的哪一个方法的"><span class="toc-number">8.</span> <span class="toc-text">引申 8.  不使用第三方，如何知道已经上线的 App 崩溃问题， 具体到哪一个类的哪一个方法的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iOS-中内省的几个方法"><span class="toc-number"></span> <span class="toc-text">iOS 中内省的几个方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-2-、-isEqualToString、isEqual-区别"><span class="toc-number">1.</span> <span class="toc-text">引申 2. ==、 isEqualToString、isEqual 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-3-class-方法和-object-getClass-方法有什么区别"><span class="toc-number">2.</span> <span class="toc-text">引申 3. class 方法和 object_getClass 方法有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-深拷贝和浅拷贝"><span class="toc-number"></span> <span class="toc-text">3.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-NSString-类型为什么要用-copy-修饰"><span class="toc-number"></span> <span class="toc-text">4.NSString 类型为什么要用 copy 修饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-iOS-中-block-捕获外部局部变量实际上发生了什么？-block-中又做了什么"><span class="toc-number"></span> <span class="toc-text">5.iOS 中 block 捕获外部局部变量实际上发生了什么？__block 中又做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-iOS-Block-为什么用-copy-修饰"><span class="toc-number"></span> <span class="toc-text">6.iOS Block 为什么用 copy 修饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-为什么分类中不能创建属性-Property（runtime-除外）"><span class="toc-number"></span> <span class="toc-text">7. 为什么分类中不能创建属性 Property（runtime 除外）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#引伸：分类可以添加那些内容"><span class="toc-number">0.1.</span> <span class="toc-text">引伸：分类可以添加那些内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#引伸：Category-的实现原理"><span class="toc-number">0.2.</span> <span class="toc-text">引伸：Category 的实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#引申-使用-runtime-Associate-方法关联的对象，需要在主对象-dealloc-的时候释放么"><span class="toc-number">0.3.</span> <span class="toc-text">引申 使用 runtime Associate 方法关联的对象，需要在主对象 dealloc 的时候释放么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#引申-能否向编译后得到的类中增加实例变量，-能否向运行时创建的类中添加实力变量"><span class="toc-number">0.4.</span> <span class="toc-text">引申 能否向编译后得到的类中增加实例变量， 能否向运行时创建的类中添加实力变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#引申-主类执行了-foo-方法，分类也执行了-foo-方法，在执行的地方执行了-foo-方法，主类的-foo-会被覆盖么？-如果想只想执行主类的-foo-方法，如何去做"><span class="toc-number">0.5.</span> <span class="toc-text">引申 主类执行了 foo 方法，分类也执行了 foo 方法，在执行的地方执行了 foo 方法，主类的 foo 会被覆盖么？    如果想只想执行主类的 foo 方法，如何去做</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-load-和-initilze-的调用情况，以及子类的调用顺序问题"><span class="toc-number"></span> <span class="toc-text">8.  load 和 initilze 的调用情况，以及子类的调用顺序问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-什么是线程安全"><span class="toc-number"></span> <span class="toc-text">9. 什么是线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-你接触到的项目，哪些场景运用到了线程安全"><span class="toc-number"></span> <span class="toc-text">10. 你接触到的项目，哪些场景运用到了线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-你实现过单例模式么？-你能用几种实现方案"><span class="toc-number"></span> <span class="toc-text">11. 你实现过单例模式么？ 你能用几种实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-1-单例是怎么销毁的"><span class="toc-number">1.</span> <span class="toc-text">引申 1. 单例是怎么销毁的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-2-不使用-dispatch-once-如何-实现单例"><span class="toc-number">2.</span> <span class="toc-text">引申 2.  不使用 dispatch_once 如何 实现单例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-项目开发中，你用单例都做了什么"><span class="toc-number"></span> <span class="toc-text">12. 项目开发中，你用单例都做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-APNS-的基本原理"><span class="toc-number"></span> <span class="toc-text">13.APNS 的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-RunLoop-的基础知识"><span class="toc-number"></span> <span class="toc-text">14. RunLoop 的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何保证一个线程永远不死-常驻线程"><span class="toc-number">1.</span> <span class="toc-text">如何保证一个线程永远不死(常驻线程)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-weak-属性"><span class="toc-number"></span> <span class="toc-text">15. weak 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#延伸"><span class="toc-number">1.</span> <span class="toc-text">延伸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-UIView-和-CALayer-是什么关系"><span class="toc-number"></span> <span class="toc-text">16.UIView 和 CALayer 是什么关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-synthesize-和-dynamic-分别有什么作用"><span class="toc-number"></span> <span class="toc-text">16.  @synthesize 和 @dynamic 分别有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-static-有什么作用"><span class="toc-number"></span> <span class="toc-text">17.  static 有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-objc-在向一个对象发送消息时，发生了什么"><span class="toc-number"></span> <span class="toc-text">18. objc 在向一个对象发送消息时，发生了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-runloop-是来做什么的？runloop-和线程有什么关系？主线程默认开启了-runloop-么？子线程呢"><span class="toc-number"></span> <span class="toc-text">19. runloop 是来做什么的？runloop 和线程有什么关系？主线程默认开启了 runloop 么？子线程呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-如何手动触发一个-value-的-KVO"><span class="toc-number"></span> <span class="toc-text">20. 如何手动触发一个 value 的 KVO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-0-如何给系统-KVO-设置筛选条件"><span class="toc-number">1.</span> <span class="toc-text">引申 0 如何给系统 KVO 设置筛选条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-1-通过-KVC-修改属性会触发-KVO-么？直接修改成员变量呢"><span class="toc-number">2.</span> <span class="toc-text">引申  1.通过 KVC 修改属性会触发 KVO 么？直接修改成员变量呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-kvc-的底层实现"><span class="toc-number">3.</span> <span class="toc-text">引申  kvc 的底层实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-ViewController-生命周期"><span class="toc-number"></span> <span class="toc-text">21. ViewController 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-网络协议"><span class="toc-number"></span> <span class="toc-text">22.网络协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引申"><span class="toc-number">1.</span> <span class="toc-text">引申</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-和-HTTPS-的建立连接的过程"><span class="toc-number">2.</span> <span class="toc-text">HTTP 和 HTTPS 的建立连接的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-协议中-GET-和-POST-的区别"><span class="toc-number">3.</span> <span class="toc-text">HTTP 协议中 GET 和 POST 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-有没有使用过-performSelector"><span class="toc-number"></span> <span class="toc-text">23.  有没有使用过 performSelector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-NSTimer-在子线程执行"><span class="toc-number">1.</span> <span class="toc-text">引申 NSTimer 在子线程执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-为什么说-NSTimer-不准确"><span class="toc-number">2.</span> <span class="toc-text">引申 为什么说 NSTimer 不准确</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申：-NStimer-的循环引用"><span class="toc-number">3.</span> <span class="toc-text">引申： NStimer 的循环引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-为什么-AFN3-0-中需要设置-self-operationQueue-maxConcurrentOperationCount-1-而-AF2-0-却不需要"><span class="toc-number"></span> <span class="toc-text">24.  为什么 AFN3.0 中需要设置 self.operationQueue.maxConcurrentOperationCount = 1;而 AF2.0 却不需要</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AFNetworking-2-0-和-3-0-的区别"><span class="toc-number">1.</span> <span class="toc-text">AFNetworking 2.0 和 3.0 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-x-版本常驻线程的分析"><span class="toc-number">2.</span> <span class="toc-text">2.x 版本常驻线程的分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-x-版本不在常驻线程的分析"><span class="toc-number">3.</span> <span class="toc-text">3.x 版本不在常驻线程的分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-autoreleasePool-在何时被释放"><span class="toc-number"></span> <span class="toc-text">25. autoreleasePool 在何时被释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#子线程中的-autorelease-变量什么时候释放"><span class="toc-number">1.</span> <span class="toc-text">子线程中的 autorelease 变量什么时候释放</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#autoreleasepool-是如何实现的"><span class="toc-number">2.</span> <span class="toc-text">autoreleasepool 是如何实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#程序卡顿的原因"><span class="toc-number">3.</span> <span class="toc-text">程序卡顿的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卡顿检测的方法"><span class="toc-number">4.</span> <span class="toc-text">卡顿检测的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继续"><span class="toc-number">5.</span> <span class="toc-text">继续</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-SDWebImage-是怎么做缓存的"><span class="toc-number"></span> <span class="toc-text">27. SDWebImage 是怎么做缓存的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#28-SDWebImage-实现原理是什么？-它是如何解决-tableView-的复用时出现图片错乱问题的呢"><span class="toc-number">1.</span> <span class="toc-text">28.SDWebImage 实现原理是什么？ 它是如何解决 tableView 的复用时出现图片错乱问题的呢</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-RunTime"><span class="toc-number"></span> <span class="toc-text">30. RunTime</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类的结构体"><span class="toc-number">1.</span> <span class="toc-text">类的结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分类结构体"><span class="toc-number">2.</span> <span class="toc-text">分类结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-1-class-copyIvarList-与-class-copyPropertyList-的区别"><span class="toc-number">3.</span> <span class="toc-text">引申 1. class_copyIvarList 与 class_copyPropertyList 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-2-class-ro-t-和-class-rw-t-的区别"><span class="toc-number">4.</span> <span class="toc-text">引申 2. class_ro_t 和 class_rw_t 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-NSNotification"><span class="toc-number"></span> <span class="toc-text">31. NSNotification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-什么情况使用-weak-关键字，相比-assign-有什么不同？（轮回系列）"><span class="toc-number"></span> <span class="toc-text">32.  什么情况使用 weak 关键字，相比 assign 有什么不同？（轮回系列）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-1-关键字-copy-的用法"><span class="toc-number">1.</span> <span class="toc-text">引申 1.关键字 copy 的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引申-2-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><span class="toc-number">2.</span> <span class="toc-text">引申 2.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-说说内存管理"><span class="toc-number"></span> <span class="toc-text">33. 说说内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#杂项"><span class="toc-number"></span> <span class="toc-text">杂项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、App-包以及启动过程"><span class="toc-number"></span> <span class="toc-text">二、App 包以及启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#App-瘦身"><span class="toc-number">1.</span> <span class="toc-text">App 瘦身</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义相关"><span class="toc-number">2.</span> <span class="toc-text">定义相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-用递归写一个算法，计算从-1-到-100-的和"><span class="toc-number">3.</span> <span class="toc-text">9 用递归写一个算法，计算从 1 到 100 的和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-打乱一个数组"><span class="toc-number">4.</span> <span class="toc-text">10.打乱一个数组</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 41
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2020/10/05/Flutter-面试题/" >Flutter 面试题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2020/10/05/组件化之Target-Action/" >组件化之 Target-Action</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2020/10/05/组件化之URL-Route/" >组件化之 URL Route</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2020/10/05/组件化之Protocol匹配/" >组件化之 Protocol 匹配</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2020/10/05/iOS面试题-2/" >iOS 面试题(2)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2020/10/05/Flutter-原理/" >Flutter 原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/12</span><a class="archive-post-title" href= "/2020/06/12/CocoaPods/" >CocoaPods</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/AB-测试/" >AB 测试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/JSON相关/" >JSON相关</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/Lottie/" >Lottie</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/GUI-框架/" >GUI 框架</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/Runtime-Method-Swizzling/" >Runtime Method Swizzling</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/iOS中面向测试开发和面向行为驱动开发/" >iOS中面向测试开发和面向行为驱动开发</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/iOS系统内核XNU/" >iOS系统内核XNU</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/响应式框架的变迁/" >响应式框架的变迁</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/构建底层的发布和订阅事件总线/" >构建底层的发布和订阅事件总线</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/应对富文本需求/" >应对富文本需求</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/16</span><a class="archive-post-title" href= "/2020/02/16/Flexbox布局/" >Flexbox布局</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/01</span><a class="archive-post-title" href= "/2020/02/01/使用多线程技术带来的问题/" >使用多线程技术带来的问题</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span><a class="archive-post-title" href= "/2019/11/03/iOS-Tips/" >iOS Tips</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span><a class="archive-post-title" href= "/2019/11/03/利用-Runloop-监控卡顿/" >利用 Runloop 监控卡顿</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span><a class="archive-post-title" href= "/2019/11/03/奔溃监控/" >奔溃监控</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href= "/2019/10/26/埋点/" >埋点</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href= "/2019/10/26/架构设计/" >架构设计</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href= "/2019/10/26/链接器/" >链接器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span><a class="archive-post-title" href= "/2019/10/26/静态分析/" >静态分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2019/09/15/Auto-Layout相关/" >Auto Layout相关</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2019/09/15/App启动速度优化/" >App启动速度优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/11</span><a class="archive-post-title" href= "/2019/05/11/解析UIKit/" >解析 UIKit</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/11</span><a class="archive-post-title" href= "/2019/05/11/网络知识/" >网络知识</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span><a class="archive-post-title" href= "/2019/05/09/Runloop的理解/" >Runloop 的理解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span><a class="archive-post-title" href= "/2019/05/09/iOS中关于Weak的故事/" >iOS 中关于 weak 的故事</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/15</span><a class="archive-post-title" href= "/2019/04/15/iOS知识补齐-多线程/" >iOS 知识补齐-多线程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/28</span><a class="archive-post-title" href= "/2019/02/28/My-Mac-App-List/" >My Mac App List</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/21</span><a class="archive-post-title" href= "/2019/02/21/算法/" >算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/11</span><a class="archive-post-title" href= "/2019/02/11/Wrappers-Swift-Style-Guide/" >Wrappers' Swift Style Guide</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/11</span><a class="archive-post-title" href= "/2019/02/11/iOS知识补齐-Runtime/" >iOS 知识补齐-Runtime</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/25</span><a class="archive-post-title" href= "/2019/01/25/组件化第一步，创建私有Pod/" >组件化第一步，创建私有 Pod</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/03</span><a class="archive-post-title" href= "/2019/01/03/2019-Target/" >2019 Target</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/18</span><a class="archive-post-title" href= "/2018/12/18/利用Sourcery，进一步优化Model层，减少模板代码/" >利用 Sourcery，进一步优化 Model 层，减少模板代码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/29</span><a class="archive-post-title" href= "/2018/11/29/iOS面试题/" >iOS 面试题</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="target"><span class="iconfont-archer">&#xe606;</span>target</span>
    
        <span class="sidebar-tag-name" data-tags="iOS"><span class="iconfont-archer">&#xe606;</span>iOS</span>
    
        <span class="sidebar-tag-name" data-tags="Flutter"><span class="iconfont-archer">&#xe606;</span>Flutter</span>
    
        <span class="sidebar-tag-name" data-tags="Mac"><span class="iconfont-archer">&#xe606;</span>Mac</span>
    
        <span class="sidebar-tag-name" data-tags="Swift"><span class="iconfont-archer">&#xe606;</span>Swift</span>
    
        <span class="sidebar-tag-name" data-tags="算法"><span class="iconfont-archer">&#xe606;</span>算法</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Wrappers"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


